<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/io/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="算法," />








  <link rel="shortcut icon" type="image/x-icon" href="/io/favicon.ico?v=5.1.2" />






<meta name="description" content="总结LeetCode⼀些算法">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode">
<meta property="og:url" content="http://dty075.coding.me/io/2018/07/18/Leetcode/index.html">
<meta property="og:site_name" content="jiangling">
<meta property="og:description" content="总结LeetCode⼀些算法">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-26T13:27:40.485Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode">
<meta name="twitter:description" content="总结LeetCode⼀些算法">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/io/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://dty075.coding.me/io/2018/07/18/Leetcode/"/>





  <title>Leetcode | jiangling</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jiangling</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-entertainment">
          <a href="/io/entertainment/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-diamond"></i> <br />
            
            珊瑚海
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/io/life/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pagelines"></i> <br />
            
            青花
          </a>
        </li>
      
        
        <li class="menu-item menu-item-language">
          <a href="/io/language/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-compass"></i> <br />
            
            带你去旅行
          </a>
        </li>
      
        
        <li class="menu-item menu-item-work">
          <a href="/io/work/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />
            
            烟火里的尘埃
          </a>
        </li>
      
        
        <li class="menu-item menu-item-technology">
          <a href="/io/technology/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-balance-scale"></i> <br />
            
            天空之城
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://dty075.coding.me/io/io/2018/07/18/Leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dty075">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/io/images/flower.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiangling">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-18T19:25:58+08:00">
                2018-07-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-07-26T21:27:40+08:00">
                2018-07-26
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/io/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/io/2018/07/18/Leetcode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/18/Leetcode/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>总结<a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank" rel="noopener">LeetCode</a>⼀些算法</p>
<a id="more"></a> 
<blockquote>
<p>C++的单元测试工具<br>Catch, Boost.Test, UnitTest++, lest, bandit, igloo, xUnit++, CppTest, CppUnit, CxxTest, cpputest, googletest, cute</p>
</blockquote>
<h3 id="2线性表"><a href="#2线性表" class="headerlink" title="2线性表"></a>2线性表</h3><h3 id="2-1数组"><a href="#2-1数组" class="headerlink" title="2.1数组"></a>2.1数组</h3><h4 id="2-1-1给定一个排序数组，移除已放置的重复项，使每个元素只出现一次并返回新的长度。"><a href="#2-1-1给定一个排序数组，移除已放置的重复项，使每个元素只出现一次并返回新的长度。" class="headerlink" title="2.1.1给定一个排序数组，移除已放置的重复项，使每个元素只出现一次并返回新的长度。"></a>2.1.1给定一个排序数组，移除已放置的重复项，使每个元素只出现一次并返回新的长度。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted Array</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) return 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[index] != nums[i])</span><br><span class="line">                nums[++index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return index + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted Array</span><br><span class="line">// 使用STL，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return distance(nums.begin(), unique(nums.begin(), nums.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2跟进“删除重复”：如果复制最多允许两次？"><a href="#2-1-2跟进“删除重复”：如果复制最多允许两次？" class="headerlink" title="2.1.2跟进“删除重复”：如果复制最多允许两次？"></a>2.1.2跟进“删除重复”：如果复制最多允许两次？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted Array II</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">// @author hex108 (https://github.com/hex108)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if (nums.size() &lt;= 2) return nums.size();</span><br><span class="line">    int index = 2;</span><br><span class="line">    for (int i = 2; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        if (nums[i] != nums[index - 2])</span><br><span class="line">            nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted Array II</span><br><span class="line">// @author 虞航仲 (http://weibo.com/u/1666779725)</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        const int n = nums.size();</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; i &lt; n - 1 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; nums[i] == nums[i + 1])</span><br><span class="line">                continue;</span><br><span class="line">            nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3假设一个排序的数组在你事先不知道的某个枢轴旋转。-例如，0-1-2-4-5-6-7可能变成4-5-6-7-0-1-2-。给你一个目标值进行搜索。如果在数组中找到它的索引，否则返回-1。你可能假设数组中没有重复。"><a href="#2-1-3假设一个排序的数组在你事先不知道的某个枢轴旋转。-例如，0-1-2-4-5-6-7可能变成4-5-6-7-0-1-2-。给你一个目标值进行搜索。如果在数组中找到它的索引，否则返回-1。你可能假设数组中没有重复。" class="headerlink" title="2.1.3假设一个排序的数组在你事先不知道的某个枢轴旋转。(例如，0 1 2 4 5 6 7可能变成4 5 6 7 0 1 2)。给你一个目标值进行搜索。如果在数组中找到它的索引，否则返回-1。你可能假设数组中没有重复。"></a>2.1.3假设一个排序的数组在你事先不知道的某个枢轴旋转。(例如，0 1 2 4 5 6 7可能变成4 5 6 7 0 1 2)。给你一个目标值进行搜索。如果在数组中找到它的索引，否则返回-1。你可能假设数组中没有重复。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Search in Rotated Sorted Array</span><br><span class="line">// 时间复杂度O(logn)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(const vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int first = 0, last = nums.size();</span><br><span class="line">        while (first != last) &#123;</span><br><span class="line">            const int mid = first + (last - first) / 2;</span><br><span class="line">            if (nums[mid] == target)</span><br><span class="line">                return mid;</span><br><span class="line">            if (nums[first] &lt;= nums[mid]) &#123;</span><br><span class="line">                if (nums[first] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    last = mid;</span><br><span class="line">                else</span><br><span class="line">                    first = mid + 1;</span><br><span class="line">            &#125; </span><br><span class="line">            else &#123;</span><br><span class="line">                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1])</span><br><span class="line">                    first = mid + 1;</span><br><span class="line">                else</span><br><span class="line">                    last = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4跟进“旋转排序数组中的搜索”：如果允许重复的话怎么办？这会影响运行时的复杂性吗？如何和为什么？编写一个函数来确定给定的目标是否在数组中。"><a href="#2-1-4跟进“旋转排序数组中的搜索”：如果允许重复的话怎么办？这会影响运行时的复杂性吗？如何和为什么？编写一个函数来确定给定的目标是否在数组中。" class="headerlink" title="2.1.4跟进“旋转排序数组中的搜索”：如果允许重复的话怎么办？这会影响运行时的复杂性吗？如何和为什么？编写一个函数来确定给定的目标是否在数组中。"></a>2.1.4跟进“旋转排序数组中的搜索”：如果允许重复的话怎么办？这会影响运行时的复杂性吗？如何和为什么？编写一个函数来确定给定的目标是否在数组中。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Search in Rotated Sorted Array II</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(const vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int first = 0, last = nums.size();</span><br><span class="line">        while (first != last) &#123;</span><br><span class="line">            const int mid = first + (last - first) / 2;</span><br><span class="line">            if (nums[mid] == target)</span><br><span class="line">                return true;</span><br><span class="line">            if (nums[first] &lt; nums[mid]) &#123;</span><br><span class="line">                if (nums[first] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    last = mid;</span><br><span class="line">                else</span><br><span class="line">                    first = mid + 1;</span><br><span class="line">                &#125; else if (nums[first] &gt; nums[mid]) &#123;</span><br><span class="line">                    if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1])</span><br><span class="line">                        first = mid + 1;</span><br><span class="line">                    else</span><br><span class="line">                        last = mid;</span><br><span class="line">                &#125; else</span><br><span class="line">                    //skip duplicate one</span><br><span class="line">                    first++;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5有两个大小分别为m和n的排序数组a和b。找到两个排序数组的中间值。总的运行时复杂度应该是O-log-m-n-。"><a href="#2-1-5有两个大小分别为m和n的排序数组a和b。找到两个排序数组的中间值。总的运行时复杂度应该是O-log-m-n-。" class="headerlink" title="2.1.5有两个大小分别为m和n的排序数组a和b。找到两个排序数组的中间值。总的运行时复杂度应该是O(log(m+n))。"></a>2.1.5有两个大小分别为m和n的排序数组a和b。找到两个排序数组的中间值。总的运行时复杂度应该是O(log(m+n))。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Median of Two Sorted Arrays</span><br><span class="line">// 时间复杂度O(log(m+n))，空间复杂度O(log(m+n))</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">        const int m = A.size();</span><br><span class="line">        const int n = B.size();</span><br><span class="line">        int total = m + n;</span><br><span class="line">        if (total &amp; 0x1)</span><br><span class="line">            return find_kth(A.begin(), m, B.begin(), n, total / 2 + 1);</span><br><span class="line">        else</span><br><span class="line">            return (find_kth(A.begin(), m, B.begin(), n, total / 2)</span><br><span class="line">                + find_kth(A.begin(), m, B.begin(), n, total / 2 + 1)) / 2.0;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">    static int find_kth(std::vector&lt;int&gt;::const_iterator A, int m,</span><br><span class="line">    std::vector&lt;int&gt;::const_iterator B, int n, int k) &#123;</span><br><span class="line">        //always assume that m is equal or smaller than n</span><br><span class="line">        if (m &gt; n) return find_kth(B, n, A, m, k);</span><br><span class="line">        if (m == 0) return *(B + k - 1);</span><br><span class="line">        if (k == 1) return min(*A, *B);</span><br><span class="line">        //divide k into two parts</span><br><span class="line">        int ia = min(k / 2, m), ib = k - ia;</span><br><span class="line">        if (*(A + ia - 1) &lt; *(B + ib - 1))</span><br><span class="line">            return find_kth(A + ia, m - ia, B, n, k - ia);</span><br><span class="line">        else if (*(A + ia - 1) &gt; *(B + ib - 1))</span><br><span class="line">            return find_kth(A, m, B + ib, n - ib, k - ib);</span><br><span class="line">        else</span><br><span class="line">            return A[ia - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-6给定一个未排序的整数数组，找到最长的连续元素序列的长度。例如，给定-100，4，200，1，3，2-，最长的连续元素序列是-1，2，3，4-。返回它的长度：4。您的算法应该以O-n-复杂度运行。"><a href="#2-1-6给定一个未排序的整数数组，找到最长的连续元素序列的长度。例如，给定-100，4，200，1，3，2-，最长的连续元素序列是-1，2，3，4-。返回它的长度：4。您的算法应该以O-n-复杂度运行。" class="headerlink" title="2.1.6给定一个未排序的整数数组，找到最长的连续元素序列的长度。例如，给定[100，4，200，1，3，2]，最长的连续元素序列是[1，2，3，4]。返回它的长度：4。您的算法应该以O(n)复杂度运行。"></a>2.1.6给定一个未排序的整数数组，找到最长的连续元素序列的长度。例如，给定[100，4，200，1，3，2]，最长的连续元素序列是[1，2，3，4]。返回它的长度：4。您的算法应该以O(n)复杂度运行。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Leet Code, Longest Consecutive Sequence</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(const vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">        unordered_map&lt;int, bool&gt; used;</span><br><span class="line">        for (auto i : nums) used[i] = false;</span><br><span class="line">        int longest = 0;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            if (used[i]) continue;</span><br><span class="line">            int length = 1;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            for (int j = i + 1; used.find(j) != used.end(); ++j) &#123;</span><br><span class="line">                used[j] = true;</span><br><span class="line">                ++length;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = i - 1; used.find(j) != used.end(); --j) &#123;</span><br><span class="line">                used[j] = true;</span><br><span class="line">                ++length;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = max(longest, length);</span><br><span class="line">        &#125;</span><br><span class="line">        return longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Leet Code, Longest Consecutive Sequence</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">// Author: @advancedxy</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    int size = nums.size();</span><br><span class="line">    int l = 1;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        if (map.find(nums[i]) != map.end()) continue;</span><br><span class="line">        map[nums[i]] = 1;</span><br><span class="line">        if (map.find(nums[i] - 1) != map.end()) &#123;</span><br><span class="line">            l = max(l, mergeCluster(map, nums[i] - 1, nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.find(nums[i] + 1) != map.end()) &#123;</span><br><span class="line">            l = max(l, mergeCluster(map, nums[i], nums[i] + 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return size == 0 ? 0 : l;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">    int mergeCluster(unordered_map&lt;int, int&gt; &amp;map, int left, int right) &#123;</span><br><span class="line">        int upper = right + map[right] - 1;</span><br><span class="line">        int lower = left - map[left] + 1;</span><br><span class="line">        int length = upper - lower + 1;</span><br><span class="line">        map[upper] = length;</span><br><span class="line">        map[lower] = length;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-7给定一个整数数组，找到两个数字，使它们相加成一个特定的目标数。函数twoSum应该返回两个数字的索引，以便它们加到目标，其中index1必须小于index2。请注意，返回的答案-index1和index2-都不是基于零的。你可以假设每个输入都有一个精确的解。输入：数字＝-2-7-11-15-，目标＝9-输出：index1＝1，index2＝2"><a href="#2-1-7给定一个整数数组，找到两个数字，使它们相加成一个特定的目标数。函数twoSum应该返回两个数字的索引，以便它们加到目标，其中index1必须小于index2。请注意，返回的答案-index1和index2-都不是基于零的。你可以假设每个输入都有一个精确的解。输入：数字＝-2-7-11-15-，目标＝9-输出：index1＝1，index2＝2" class="headerlink" title="2.1.7给定一个整数数组，找到两个数字，使它们相加成一个特定的目标数。函数twoSum应该返回两个数字的索引，以便它们加到目标，其中index1必须小于index2。请注意，返回的答案(index1和index2)都不是基于零的。你可以假设每个输入都有一个精确的解。输入：数字＝{2,7,11,15}，目标＝9 输出：index1＝1，index2＝2"></a>2.1.7给定一个整数数组，找到两个数字，使它们相加成一个特定的目标数。函数<code>twoSum</code>应该返回两个数字的索引，以便它们加到目标，其中<code>index1</code>必须小于<code>index2</code>。请注意，返回的答案(<code>index1</code>和<code>index2</code>)都不是基于零的。你可以假设每个输入都有一个精确的解。输入：数字＝{2,7,11,15}，目标＝9 输出：<code>index1＝1</code>，<code>index2＝2</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Two Sum</span><br><span class="line">// 方法2：hash。用一个哈希表，存储每个数对应的下标</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; mapping;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            mapping[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            const int gap = target - nums[i];</span><br><span class="line">            if (mapping.find(gap) != mapping.end() &amp;&amp; mapping[gap] &gt; i) &#123;</span><br><span class="line">                result.push_back(i + 1);</span><br><span class="line">                result.push_back(mapping[gap] + 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-8给定n个整数的数组S，其中是否有元素a-b-c使a-b-c-0？查找数组中给出零和的所有唯一三元组。注意：·三元组-a-b-c-必须是非降序的。-即，a≤b≤c-·解集不能包含重复的三元组。例如，给定数组s-1-0-1-2-1-1-4-，解集为：-1-0-1-1-1-2"><a href="#2-1-8给定n个整数的数组S，其中是否有元素a-b-c使a-b-c-0？查找数组中给出零和的所有唯一三元组。注意：·三元组-a-b-c-必须是非降序的。-即，a≤b≤c-·解集不能包含重复的三元组。例如，给定数组s-1-0-1-2-1-1-4-，解集为：-1-0-1-1-1-2" class="headerlink" title="2.1.8给定n个整数的数组S，其中是否有元素a,b,c使a+b+c=0？查找数组中给出零和的所有唯一三元组。注意：·三元组(a,b,c)必须是非降序的。(即，a≤b≤c)·解集不能包含重复的三元组。例如，给定数组s={-1 0 1 2-1-1-4}，解集为：(-1,0,1)(-1,-1,2)"></a>2.1.8给定n个整数的数组S，其中是否有元素a,b,c使a+b+c=0？查找数组中给出零和的所有唯一三元组。注意：·三元组(a,b,c)必须是非降序的。(即，a≤b≤c)·解集不能包含重复的三元组。例如，给定数组s={-1 0 1 2-1-1-4}，解集为：(-1,0,1)(-1,-1,2)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, 3Sum</span><br><span class="line">// 先排序，然后左右夹逼，注意跳过重复的数，时间复杂度O(n^2)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        if (nums.size() &lt; 3) return result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        const int target = 0;</span><br><span class="line">        auto last = nums.end();</span><br><span class="line">        for (auto i = nums.begin(); i &lt; last-2; ++i) &#123;</span><br><span class="line">            auto j = i+1;</span><br><span class="line">            if (i &gt; nums.begin() &amp;&amp; *i == *(i-1)) continue;</span><br><span class="line">            auto k = last-1;</span><br><span class="line">            while (j &lt; k) &#123;</span><br><span class="line">                if (*i + *j + *k &lt; target) &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                    while(*j == *(j - 1) &amp;&amp; j &lt; k) ++j;</span><br><span class="line">                &#125; else if (*i + *j + *k &gt; target) &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                    while(*k == *(k + 1) &amp;&amp; j &lt; k) --k;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result.push_back(&#123; *i, *j, *k &#125;);</span><br><span class="line">                    ++j;</span><br><span class="line">                    --k;</span><br><span class="line">                    while(*j == *(j - 1) &amp;&amp; *k == *(k + 1) &amp;&amp; j &lt; k) ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-9给定n个整数的数组，在S中找到三个整数，使得和最接近一个给定的数，target。返回这三个整数的和。您可以假设每个输入都有一个解。例如，给定数组s-1-2-1-4-，target-1。与目标最接近的和是2。-1-2-1-2-。"><a href="#2-1-9给定n个整数的数组，在S中找到三个整数，使得和最接近一个给定的数，target。返回这三个整数的和。您可以假设每个输入都有一个解。例如，给定数组s-1-2-1-4-，target-1。与目标最接近的和是2。-1-2-1-2-。" class="headerlink" title="2.1.9给定n个整数的数组，在S中找到三个整数，使得和最接近一个给定的数，target。返回这三个整数的和。您可以假设每个输入都有一个解。例如，给定数组s={-1 2 1-4}，target=1。与目标最接近的和是2。(-1+2+1=2)。"></a>2.1.9给定n个整数的数组，在S中找到三个整数，使得和最接近一个给定的数，target。返回这三个整数的和。您可以假设每个输入都有一个解。例如，给定数组s={-1 2 1-4}，target=1。与目标最接近的和是2。(-1+2+1=2)。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, 3Sum Closest</span><br><span class="line">// 先排序，然后左右夹逼，时间复杂度O(n^2)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int min_gap = INT_MAX;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        for (auto a = nums.begin(); a != prev(nums.end(), 2); ++a) &#123;</span><br><span class="line">            auto b = next(a);</span><br><span class="line">            auto c = prev(nums.end());</span><br><span class="line">            while (b &lt; c) &#123;</span><br><span class="line">                const int sum = *a + *b + *c;</span><br><span class="line">                const int gap = abs(sum - target);</span><br><span class="line">                if (gap &lt; min_gap) &#123;</span><br><span class="line">                    result = sum;</span><br><span class="line">                    min_gap = gap;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sum &lt; target) </span><br><span class="line">                    ++b;</span><br><span class="line">                else              </span><br><span class="line">                    --c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-10给定n个整数的数组S，其中是否有a-b-c和d元素使得a-b-c-d-target？找到数组中所有给出目标和的唯一四重元。注意：-元素在四重集-a-b-c-d-中必须是非降序的。-即，a≤b≤c≤d-·解集。例如，给定数组s-1-0-1-0-2-2-，target-0。解集为：-1-0-0-1-2-1-1-2-2-0-0-2"><a href="#2-1-10给定n个整数的数组S，其中是否有a-b-c和d元素使得a-b-c-d-target？找到数组中所有给出目标和的唯一四重元。注意：-元素在四重集-a-b-c-d-中必须是非降序的。-即，a≤b≤c≤d-·解集。例如，给定数组s-1-0-1-0-2-2-，target-0。解集为：-1-0-0-1-2-1-1-2-2-0-0-2" class="headerlink" title="2.1.10给定n个整数的数组S，其中是否有a,b,c和d元素使得a+b+c+d=target？找到数组中所有给出目标和的唯一四重元。注意：.元素在四重集(a,b,c,d)中必须是非降序的。(即，a≤b≤c≤d)·解集。例如，给定数组s={1 0-1 0-2 2}，target=0。解集为：(-1,0,0,1)(-2,-1,1,2)(-2,0,0,2)"></a>2.1.10给定n个整数的数组S，其中是否有a,b,c和d元素使得a+b+c+d=target？找到数组中所有给出目标和的唯一四重元。注意：.元素在四重集(a,b,c,d)中必须是非降序的。(即，a≤b≤c≤d)·解集。例如，给定数组s={1 0-1 0-2 2}，target=0。解集为：(-1,0,0,1)(-2,-1,1,2)(-2,0,0,2)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, 4Sum</span><br><span class="line">// 先排序，然后左右夹逼，时间复杂度O(n^3)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        if (nums.size() &lt; 4) return result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        auto last = nums.end();</span><br><span class="line">        for (auto a = nums.begin(); a &lt; prev(last, 3); ++a) &#123;</span><br><span class="line">            for (auto b = next(a); b &lt; prev(last, 2); ++b) &#123;</span><br><span class="line">                auto c = next(b);</span><br><span class="line">                auto d = prev(last);</span><br><span class="line">                while (c &lt; d) &#123;</span><br><span class="line">                    if (*a + *b + *c + *d &lt; target) &#123;</span><br><span class="line">                        ++c;</span><br><span class="line">                    &#125; else if (*a + *b + *c + *d &gt; target) &#123;</span><br><span class="line">                        --d;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        result.push_back(&#123; *a, *b, *c, *d &#125;);</span><br><span class="line">                        ++c;</span><br><span class="line">                        --d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(result.begin(), result.end());</span><br><span class="line">        result.erase(unique(result.begin(), result.end()), result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, 4Sum</span><br><span class="line">// 用一个hashmap先缓存两个数的和</span><br><span class="line">// 时间复杂度，平均O(n^2)，最坏O(n^4)，空间复杂度O(n^2)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        if (nums.size() &lt; 4) return result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        unordered_map&lt;int, vector&lt;pair&lt;int, int&gt; &gt; &gt; cache;</span><br><span class="line">        for (size_t a = 0; a &lt; nums.size(); ++a) &#123;</span><br><span class="line">            for (size_t b = a + 1; b &lt; nums.size(); ++b) &#123;</span><br><span class="line">                cache[nums[a] + nums[b]].push_back(pair&lt;int, int&gt;(a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int c = 0; c &lt; nums.size(); ++c) &#123;</span><br><span class="line">            for (size_t d = c + 1; d &lt; nums.size(); ++d) &#123;</span><br><span class="line">                const int key = target - nums[c] - nums[d];</span><br><span class="line">                if (cache.find(key) == cache.end()) continue;</span><br><span class="line">                const auto&amp; vec = cache[key];</span><br><span class="line">                for (size_t k = 0; k &lt; vec.size(); ++k) &#123;</span><br><span class="line">                    if (c &lt;= vec[k].second)</span><br><span class="line">                        continue; // 有重叠</span><br><span class="line">                    result.push_back( &#123; nums[vec[k].first],</span><br><span class="line">                            nums[vec[k].second], nums[c], nums[d] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(result.begin(), result.end());</span><br><span class="line">        result.erase(unique(result.begin(), result.end()), result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, 4Sum</span><br><span class="line">// 用一个 hashmap 先缓存两个数的和</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(n^2)</span><br><span class="line">// @author 龚陆安(http://weibo.com/luangong)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        if (nums.size() &lt; 4) return result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        unordered_multimap&lt;int, pair&lt;int, int&gt;&gt; cache;</span><br><span class="line">        for (int i = 0; i + 1 &lt; nums.size(); ++i)</span><br><span class="line">            for (int j = i + 1; j &lt; nums.size(); ++j)</span><br><span class="line">                cache.insert(make_pair(nums[i] + nums[j], make_pair(i, j)));</span><br><span class="line">        for (auto i = cache.begin(); i != cache.end(); ++i) &#123;</span><br><span class="line">            int x = target - i-&gt;first;</span><br><span class="line">            auto range = cache.equal_range(x);</span><br><span class="line">            for (auto j = range.first; j != range.second; ++j) &#123;</span><br><span class="line">                auto a = i-&gt;second.first;</span><br><span class="line">                auto b = i-&gt;second.second;</span><br><span class="line">                auto c = j-&gt;second.first;</span><br><span class="line">                auto d = j-&gt;second.second;</span><br><span class="line">                if (a != c &amp;&amp; a != d &amp;&amp; b != c &amp;&amp; b != d) &#123;</span><br><span class="line">                    vector&lt;int&gt; vec = &#123; nums[a], nums[b], nums[c], nums[d] &#125;;</span><br><span class="line">                    sort(vec.begin(), vec.end());</span><br><span class="line">                    result.push_back(vec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(result.begin(), result.end());</span><br><span class="line">        result.erase(unique(result.begin(), result.end()), result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, 4Sum</span><br><span class="line">// 先排序，然后左右夹逼，时间复杂度O(n^3logn)，空间复杂度O(1)，会超时</span><br><span class="line">// 跟方法1相比，表面上优化了，实际上更慢了，切记！</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        if (nums.size() &lt; 4) return result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        auto last = nums.end();</span><br><span class="line">        for (auto a = nums.begin(); a &lt; prev(last, 3);</span><br><span class="line">                a = upper_bound(a, prev(last, 3), *a)) &#123;</span><br><span class="line">            for (auto b = next(a); b &lt; prev(last, 2);</span><br><span class="line">                    b = upper_bound(b, prev(last, 2), *b)) &#123;</span><br><span class="line">                auto c = next(b);</span><br><span class="line">                auto d = prev(last);</span><br><span class="line">                while (c &lt; d) &#123;</span><br><span class="line">                    if (*a + *b + *c + *d &lt; target) &#123;</span><br><span class="line">                        c = upper_bound(c, d, *c);</span><br><span class="line">                    &#125; else if (*a + *b + *c + *d &gt; target) &#123;</span><br><span class="line">                        d = prev(lower_bound(c, d, *d));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        result.push_back(&#123; *a, *b, *c, *d &#125;);</span><br><span class="line">                        c = upper_bound(c, d, *c);</span><br><span class="line">                        d = prev(lower_bound(c, d, *d));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-11给定一个数组和一个值，移除该值的所有实例并返回新的长度。元素的顺序可以更改。"><a href="#2-1-11给定一个数组和一个值，移除该值的所有实例并返回新的长度。元素的顺序可以更改。" class="headerlink" title="2.1.11给定一个数组和一个值，移除该值的所有实例并返回新的长度。元素的顺序可以更改。"></a>2.1.11给定一个数组和一个值，移除该值的所有实例并返回新的长度。元素的顺序可以更改。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Element</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (nums[i] != target) &#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Element</span><br><span class="line">// 使用remove()，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        return distance(nums.begin(), remove(nums.begin(), nums.end(), target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-12实现下一个排列，它在字典上将数字重新排列成更大的编号排列。如果这种排列不可能，它必须按照最低可能的顺序-即按升序排序-重新排列。替换必须就位，不要分配额外的内存。以下是一些例子。输入在左边的列中，相应的输出在右边的列中。"><a href="#2-1-12实现下一个排列，它在字典上将数字重新排列成更大的编号排列。如果这种排列不可能，它必须按照最低可能的顺序-即按升序排序-重新排列。替换必须就位，不要分配额外的内存。以下是一些例子。输入在左边的列中，相应的输出在右边的列中。" class="headerlink" title="2.1.12实现下一个排列，它在字典上将数字重新排列成更大的编号排列。如果这种排列不可能，它必须按照最低可能的顺序(即按升序排序)重新排列。替换必须就位，不要分配额外的内存。以下是一些例子。输入在左边的列中，相应的输出在右边的列中。"></a>2.1.12实现下一个排列，它在字典上将数字重新排列成更大的编号排列。如果这种排列不可能，它必须按照最低可能的顺序(即按升序排序)重新排列。替换必须就位，不要分配额外的内存。以下是一些例子。输入在左边的列中，相应的输出在右边的列中。</h4><pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Next Permutation</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void nextPermutation(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">        next_permutation(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename BidiIt&gt;</span><br><span class="line">    bool next_permutation(BidiIt first, BidiIt last) &#123;</span><br><span class="line">        // Get a reversed range to simplify reversed traversal.</span><br><span class="line">        const auto rfirst = reverse_iterator&lt;BidiIt&gt;(last);</span><br><span class="line">        const auto rlast = reverse_iterator&lt;BidiIt&gt;(first);</span><br><span class="line">        // Begin from the second last element to the first element.</span><br><span class="line">        auto pivot = next(rfirst);</span><br><span class="line">        // Find `pivot`, which is the first element that is no less than its</span><br><span class="line">        // successor.  `Prev` is used since `pivort` is a `reversed_iterator`.</span><br><span class="line">        while (pivot != rlast &amp;&amp; *pivot &gt;= *prev(pivot))</span><br><span class="line">            ++pivot;</span><br><span class="line">        // No such elemenet found, current sequence is already the largest</span><br><span class="line">        // permutation, then rearrange to the first permutation and return false.</span><br><span class="line">        if (pivot == rlast) &#123;</span><br><span class="line">            reverse(rfirst, rlast);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // Scan from right to left, find the first element that is greater than</span><br><span class="line">        // `pivot`.</span><br><span class="line">        auto change = find_if(rfirst, pivot, bind1st(less&lt;int&gt;(), *pivot));</span><br><span class="line">        swap(*change, *pivot);</span><br><span class="line">        reverse(rfirst, pivot);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-13集合-1-2-3，…，n-总共包含n！唯一排列。通过列出和标记所有排列顺序，我们得到下面的序列（即n＝3）：“123”132“213”231“312”321“给定n和k，返回第k个排列顺序。注：给定n将包含在1和9之间。"><a href="#2-1-13集合-1-2-3，…，n-总共包含n！唯一排列。通过列出和标记所有排列顺序，我们得到下面的序列（即n＝3）：“123”132“213”231“312”321“给定n和k，返回第k个排列顺序。注：给定n将包含在1和9之间。" class="headerlink" title="2.1.13集合[1,2,3，…，n]总共包含n！唯一排列。通过列出和标记所有排列顺序，我们得到下面的序列（即n＝3）：“123”132“213”231“312”321“给定n和k，返回第k个排列顺序。注：给定n将包含在1和9之间。"></a>2.1.13集合[1,2,3，…，n]总共包含n！唯一排列。通过列出和标记所有排列顺序，我们得到下面的序列（即n＝3）：“123”132“213”231“312”321“给定n和k，返回第k个排列顺序。注：给定n将包含在1和9之间。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Permutation Sequence</span><br><span class="line">// 使用next_permutation()，TLE</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string getPermutation(int n, int k) &#123;</span><br><span class="line">        string s(n, &apos;0&apos;);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">            s[i] += i+1;</span><br><span class="line">        for (int i = 0; i &lt; k-1; ++i)</span><br><span class="line">            next_permutation(s.begin(), s.end());</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename BidiIt&gt;</span><br><span class="line">    bool next_permutation(BidiIt first, BidiIt last) &#123;</span><br><span class="line">        // 代码见上一题 Next Permutation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-14根据：Sudoku谜题-规则http：-sudoku-com-au-therules-aspx-确定sudoku是否有效。sudoku板可以部分填充，空单元格中填充字符“-”。"><a href="#2-1-14根据：Sudoku谜题-规则http：-sudoku-com-au-therules-aspx-确定sudoku是否有效。sudoku板可以部分填充，空单元格中填充字符“-”。" class="headerlink" title="2.1.14根据：Sudoku谜题-规则http：/sudoku.com.au/therules.aspx-确定sudoku是否有效。sudoku板可以部分填充，空单元格中填充字符“.”。"></a>2.1.14根据：Sudoku谜题-规则http：/sudoku.com.au/therules.aspx-确定sudoku是否有效。sudoku板可以部分填充，空单元格中填充字符“.”。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Valid Sudoku</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(const vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        bool used[9];</span><br><span class="line">        for (int i = 0; i &lt; 9; ++i) &#123;</span><br><span class="line">            fill(used, used + 9, false);</span><br><span class="line">            for (int j = 0; j &lt; 9; ++j) // 检查行</span><br><span class="line">                if (!check(board[i][j], used))</span><br><span class="line">                    return false;</span><br><span class="line">            fill(used, used + 9, false);</span><br><span class="line">            for (int j = 0; j &lt; 9; ++j) // 检查列</span><br><span class="line">                if (!check(board[j][i], used))</span><br><span class="line">                    return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int r = 0; r &lt; 3; ++r) // 检查 9 个子格子</span><br><span class="line">            for (int c = 0; c &lt; 3; ++c) &#123;</span><br><span class="line">                fill(used, used + 9, false);</span><br><span class="line">                for (int i = r * 3; i &lt; r * 3 + 3; ++i)</span><br><span class="line">                    for (int j = c * 3; j &lt; c * 3 + 3; ++j)</span><br><span class="line">                        if (!check(board[i][j], used))</span><br><span class="line">                            return false;</span><br><span class="line">            &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool check(char ch, bool used[9]) &#123;</span><br><span class="line">        if (ch == &apos;.&apos;) return true;</span><br><span class="line">        if (used[ch - &apos;1&apos;]) return false;</span><br><span class="line">        return used[ch - &apos;1&apos;] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-15如果n个非负整数表示一个标高图，其中每个杆的宽度为1，计算它在下雨后能陷多少水。例如，给定-0，1，0，2，1，1，1，3，2，1，1-，返回6。"><a href="#2-1-15如果n个非负整数表示一个标高图，其中每个杆的宽度为1，计算它在下雨后能陷多少水。例如，给定-0，1，0，2，1，1，1，3，2，1，1-，返回6。" class="headerlink" title="2.1.15如果n个非负整数表示一个标高图，其中每个杆的宽度为1，计算它在下雨后能陷多少水。例如，给定[0，1，0，2，1，1，1，3，2，1，1]，返回6。"></a>2.1.15如果n个非负整数表示一个标高图，其中每个杆的宽度为1，计算它在下雨后能陷多少水。例如，给定[0，1，0，2，1，1，1，3，2，1，1]，返回6。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Trapping Rain Water</span><br><span class="line">// 思路2，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">// 扫描一遍，找到最高的柱子，这个柱子将数组分为两半；</span><br><span class="line">// 处理左边一半；</span><br><span class="line">// 处理右边一半。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        const int n = A.size();</span><br><span class="line">        int max = 0; // 最高的柱子，将数组分为两半</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">            if (A[i] &gt; A[max]) max = i;</span><br><span class="line">        int water = 0;</span><br><span class="line">        for (int i = 0, peak = 0; i &lt; max; i++)</span><br><span class="line">            if (A[i] &gt; peak) peak = A[i];</span><br><span class="line">            else water += peak - A[i];</span><br><span class="line">        for (int i = n - 1, top = 0; i &gt; max; i--)</span><br><span class="line">            if (A[i] &gt; top) top = A[i];</span><br><span class="line">            else water += top - A[i];</span><br><span class="line">        return water;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-16给你一个表示图像的n×n的2D矩阵。将图像旋转90度-顺时针方向-。跟进：你能在适当的地方做这个吗？"><a href="#2-1-16给你一个表示图像的n×n的2D矩阵。将图像旋转90度-顺时针方向-。跟进：你能在适当的地方做这个吗？" class="headerlink" title="2.1.16给你一个表示图像的n×n的2D矩阵。将图像旋转90度(顺时针方向)。跟进：你能在适当的地方做这个吗？"></a>2.1.16给你一个表示图像的n×n的2D矩阵。将图像旋转90度(顺时针方向)。跟进：你能在适当的地方做这个吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Rotate Image</span><br><span class="line">// 思路 1，时间复杂度O(n^2)，空间复杂度O(1)，首先沿着副对角线翻转一次，然后沿着水平中线翻转一次。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        const int n = matrix.size();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i)  // 沿着副对角线反转</span><br><span class="line">            for (int j = 0; j &lt; n - i; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - 1 - j][n - 1 - i]);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n / 2; ++i) // 沿着水平中线反转</span><br><span class="line">            for (int j = 0; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - 1 - i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Rotate Image</span><br><span class="line">// 思路 2，时间复杂度O(n^2)，空间复杂度O(1)，首先沿着水平中线翻转一次，然后沿着主对角线翻转一次。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        const int n = matrix.size();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n / 2; ++i) // 沿着水平中线反转</span><br><span class="line">            for (int j = 0; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - 1 - i][j]);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i)  // 沿着主对角线反转</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-17给定一个数字，表示为一个数字数组，再加上一个数字。（高精度加法）"><a href="#2-1-17给定一个数字，表示为一个数字数组，再加上一个数字。（高精度加法）" class="headerlink" title="2.1.17给定一个数字，表示为一个数字数组，再加上一个数字。（高精度加法）"></a>2.1.17给定一个数字，表示为一个数字数组，再加上一个数字。（高精度加法）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Plus One</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, 1);</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // 0 &lt;= digit &lt;= 9</span><br><span class="line">    void add(vector&lt;int&gt; &amp;digits, int digit) &#123;</span><br><span class="line">        int c = digit;  // carry, 进位</span><br><span class="line">        for (auto it = digits.rbegin(); it != digits.rend(); ++it) &#123;</span><br><span class="line">            *it += c;</span><br><span class="line">            c = *it / 10;</span><br><span class="line">            *it %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if (c &gt; 0) digits.insert(digits.begin(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Plus One</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, 1);</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // 0 &lt;= digit &lt;= 9</span><br><span class="line">    void add(vector&lt;int&gt; &amp;digits, int digit) &#123;</span><br><span class="line">        int c = digit;  // carry, 进位</span><br><span class="line">        for_each(digits.rbegin(), digits.rend(), [&amp;c](int &amp;d)&#123;</span><br><span class="line">            d += c;</span><br><span class="line">            c = d / 10;</span><br><span class="line">            d %= 10;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (c &gt; 0) digits.insert(digits.begin(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-18你在爬楼梯。爬到山顶需要n步。每次你都可以爬1或2个台阶。你能用多少种不同的方式爬到山顶？"><a href="#2-1-18你在爬楼梯。爬到山顶需要n步。每次你都可以爬1或2个台阶。你能用多少种不同的方式爬到山顶？" class="headerlink" title="2.1.18你在爬楼梯。爬到山顶需要n步。每次你都可以爬1或2个台阶。你能用多少种不同的方式爬到山顶？"></a>2.1.18你在爬楼梯。爬到山顶需要n步。每次你都可以爬1或2个台阶。你能用多少种不同的方式爬到山顶？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Climbing Stairs</span><br><span class="line">// 迭代，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int prev = 0;</span><br><span class="line">        int cur = 1;</span><br><span class="line">        for(int i = 1; i &lt;= n ; ++i)&#123;</span><br><span class="line">            int tmp = cur;</span><br><span class="line">            cur += prev;</span><br><span class="line">            prev = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Climbing Stairs</span><br><span class="line">// 数学公式，时间复杂度O(1)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        const double s = sqrt(5);</span><br><span class="line">        return floor((pow((1+s)/2, n+1) + pow((1-s)/2, n+1))/s + 0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-19Grey代码是一个二进制数字系统，其中两个连续值仅相差一位。给定一个非负整数n表示代码中的总位数，则打印Grey码序列。Grey代码序列必须以0开头。例如，给定n-2，返回-0，1，3，2-。它的Grey代码序列是：注：·对于给定的n，Grey代码序列不是唯一定义的。·例如，-0，2，3，1-也是根据上述定义有效的灰色代码序列。·目前，法官能够根据Grey代码序列的一个实例进行判断。"><a href="#2-1-19Grey代码是一个二进制数字系统，其中两个连续值仅相差一位。给定一个非负整数n表示代码中的总位数，则打印Grey码序列。Grey代码序列必须以0开头。例如，给定n-2，返回-0，1，3，2-。它的Grey代码序列是：注：·对于给定的n，Grey代码序列不是唯一定义的。·例如，-0，2，3，1-也是根据上述定义有效的灰色代码序列。·目前，法官能够根据Grey代码序列的一个实例进行判断。" class="headerlink" title="2.1.19Grey代码是一个二进制数字系统，其中两个连续值仅相差一位。给定一个非负整数n表示代码中的总位数，则打印Grey码序列。Grey代码序列必须以0开头。例如，给定n=2，返回[0，1，3，2]。它的Grey代码序列是：注：·对于给定的n，Grey代码序列不是唯一定义的。·例如，[0，2，3，1]也是根据上述定义有效的灰色代码序列。·目前，法官能够根据Grey代码序列的一个实例进行判断。"></a>2.1.19Grey代码是一个二进制数字系统，其中两个连续值仅相差一位。给定一个非负整数n表示代码中的总位数，则打印Grey码序列。Grey代码序列必须以0开头。例如，给定n=2，返回[0，1，3，2]。它的Grey代码序列是：注：·对于给定的n，Grey代码序列不是唯一定义的。·例如，[0，2，3，1]也是根据上述定义有效的灰色代码序列。·目前，法官能够根据Grey代码序列的一个实例进行判断。</h4><pre><code>00 - 0
01 - 1
11 - 3
10 - 2
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Gray Code</span><br><span class="line">// 数学公式，时间复杂度O(2^n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        const size_t size = 1 &lt;&lt; n;  // 2^n</span><br><span class="line">        result.reserve(size);</span><br><span class="line">        for (size_t i = 0; i &lt; size; ++i)</span><br><span class="line">            result.push_back(binary_to_gray(i));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static unsigned int binary_to_gray(unsigned int n) &#123;</span><br><span class="line">        return n ^ (n &gt;&gt; 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Gray Code</span><br><span class="line">// reflect-and-prefix method</span><br><span class="line">// 时间复杂度O(2^n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        result.reserve(1&lt;&lt;n);</span><br><span class="line">        result.push_back(0);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            const int highest_bit = 1 &lt;&lt; i;</span><br><span class="line">            for (int j = result.size() - 1; j &gt;= 0; j--) // 要反着遍历，才能对称</span><br><span class="line">                result.push_back(highest_bit | result[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-20给定m×n矩阵，如果元素为0，则将其整行和列设置为0。把它放在适当的位置。你有多余的空间吗？使用O（mn）空间的直截了当的解决方案可能是个坏主意。一个简单的改进使用O（m-n）空间，但仍然不是最好的解决方案。你能设计出一个恒定的空间解决方案吗？"><a href="#2-1-20给定m×n矩阵，如果元素为0，则将其整行和列设置为0。把它放在适当的位置。你有多余的空间吗？使用O（mn）空间的直截了当的解决方案可能是个坏主意。一个简单的改进使用O（m-n）空间，但仍然不是最好的解决方案。你能设计出一个恒定的空间解决方案吗？" class="headerlink" title="2.1.20给定m×n矩阵，如果元素为0，则将其整行和列设置为0。把它放在适当的位置。你有多余的空间吗？使用O（mn）空间的直截了当的解决方案可能是个坏主意。一个简单的改进使用O（m+n）空间，但仍然不是最好的解决方案。你能设计出一个恒定的空间解决方案吗？"></a>2.1.20给定m×n矩阵，如果元素为0，则将其整行和列设置为0。把它放在适当的位置。你有多余的空间吗？使用O（mn）空间的直截了当的解决方案可能是个坏主意。一个简单的改进使用O（m+n）空间，但仍然不是最好的解决方案。你能设计出一个恒定的空间解决方案吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Set Matrix Zeroes</span><br><span class="line">// 时间复杂度O(m*n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123;</span><br><span class="line">        const size_t m = matrix.size();</span><br><span class="line">        const size_t n = matrix[0].size();</span><br><span class="line">        bool row_has_zero = false; // 第一行是否存在 0</span><br><span class="line">        bool col_has_zero = false; // 第一列是否存在 0</span><br><span class="line">        for (size_t i = 0; i &lt; n; i++)</span><br><span class="line">            if (matrix[0][i] == 0) &#123;</span><br><span class="line">                row_has_zero = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        for (size_t i = 0; i &lt; m; i++)</span><br><span class="line">            if (matrix[i][0] == 0) &#123;</span><br><span class="line">                col_has_zero = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        for (size_t i = 1; i &lt; m; i++)</span><br><span class="line">            for (size_t j = 1; j &lt; n; j++)</span><br><span class="line">                if (matrix[i][j] == 0) &#123;</span><br><span class="line">                    matrix[0][j] = 0;</span><br><span class="line">                    matrix[i][0] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">        for (size_t i = 1; i &lt; m; i++)</span><br><span class="line">            for (size_t j = 1; j &lt; n; j++)</span><br><span class="line">                if (matrix[i][0] == 0 || matrix[0][j] == 0)</span><br><span class="line">                    matrix[i][j] = 0;</span><br><span class="line">        if (row_has_zero)</span><br><span class="line">            for (size_t i = 0; i &lt; n; i++)</span><br><span class="line">                matrix[0][i] = 0;</span><br><span class="line">        if (col_has_zero)</span><br><span class="line">            for (size_t i = 0; i &lt; m; i++)</span><br><span class="line">                matrix[i][0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-21在一个环形路线上有N个加油站，第i站的汽油量是gas-i-。你有一辆有一个无限制油箱的汽车，从第i站到下一站-i-1-要cost-i-煤气费。你从加油站的一个空油箱开始旅程。如果可以绕电路一圈的话，请返回起始加油站的指数，否则返回-1。注意：解决方案保证是唯一的。"><a href="#2-1-21在一个环形路线上有N个加油站，第i站的汽油量是gas-i-。你有一辆有一个无限制油箱的汽车，从第i站到下一站-i-1-要cost-i-煤气费。你从加油站的一个空油箱开始旅程。如果可以绕电路一圈的话，请返回起始加油站的指数，否则返回-1。注意：解决方案保证是唯一的。" class="headerlink" title="2.1.21在一个环形路线上有N个加油站，第i站的汽油量是gas[i]。你有一辆有一个无限制油箱的汽车，从第i站到下一站(i+1)要cost[i]煤气费。你从加油站的一个空油箱开始旅程。如果可以绕电路一圈的话，请返回起始加油站的指数，否则返回-1。注意：解决方案保证是唯一的。"></a>2.1.21在一个环形路线上有N个加油站，第i站的汽油量是gas[i]。你有一辆有一个无限制油箱的汽车，从第i站到下一站(i+1)要cost[i]煤气费。你从加油站的一个空油箱开始旅程。如果可以绕电路一圈的话，请返回起始加油站的指数，否则返回-1。注意：解决方案保证是唯一的。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Gas Station</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123;</span><br><span class="line">        int total = 0;</span><br><span class="line">        int j = -1;</span><br><span class="line">        for (int i = 0, sum = 0; i &lt; gas.size(); ++i) &#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">            if (sum &lt; 0) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                sum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return total &gt;= 0 ? j + 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-22有N个孩子站成一排。每个孩子都被分配一个评级值。你给糖果的孩子们有以下要求：每个孩子必须至少有一个糖果。具有较高等级的孩子比邻居得到更多糖果。你必须给的最小糖果是多少？"><a href="#2-1-22有N个孩子站成一排。每个孩子都被分配一个评级值。你给糖果的孩子们有以下要求：每个孩子必须至少有一个糖果。具有较高等级的孩子比邻居得到更多糖果。你必须给的最小糖果是多少？" class="headerlink" title="2.1.22有N个孩子站成一排。每个孩子都被分配一个评级值。你给糖果的孩子们有以下要求：每个孩子必须至少有一个糖果。具有较高等级的孩子比邻居得到更多糖果。你必须给的最小糖果是多少？"></a>2.1.22有N个孩子站成一排。每个孩子都被分配一个评级值。你给糖果的孩子们有以下要求：每个孩子必须至少有一个糖果。具有较高等级的孩子比邻居得到更多糖果。你必须给的最小糖果是多少？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Candy</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt; &amp;ratings) &#123;</span><br><span class="line">        const int n = ratings.size();</span><br><span class="line">        vector&lt;int&gt; increment(n);</span><br><span class="line">        // 左右各扫描一遍</span><br><span class="line">        for (int i = 1, inc = 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (ratings[i] &gt; ratings[i - 1])</span><br><span class="line">                increment[i] = max(inc++, increment[i]);</span><br><span class="line">            else</span><br><span class="line">                inc = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 2, inc = 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if (ratings[i] &gt; ratings[i + 1])</span><br><span class="line">                increment[i] = max(inc++, increment[i]);</span><br><span class="line">            else</span><br><span class="line">                inc = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始值为n，因为每个小朋友至少一颗糖</span><br><span class="line">        return accumulate(&amp;increment[0], &amp;increment[0]+n, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-23给定一个整数数组，每个元素都会出现两次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？"><a href="#2-1-23给定一个整数数组，每个元素都会出现两次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？" class="headerlink" title="2.1.23给定一个整数数组，每个元素都会出现两次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？"></a>2.1.23给定一个整数数组，每个元素都会出现两次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？</h4><p>异或，不仅能处理两次的情况，只要出现偶数次，都可以清零。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Single Number</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            x ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Single Number</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return accumulate(nums.begin(), nums.end(), 0, bit_xor&lt;int&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-24给定一个整数数组，每个元素都会出现三次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？"><a href="#2-1-24给定一个整数数组，每个元素都会出现三次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？" class="headerlink" title="2.1.24给定一个整数数组，每个元素都会出现三次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？"></a>2.1.24给定一个整数数组，每个元素都会出现三次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Single Number II</span><br><span class="line">// 方法1，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">// 创建一个长度为sizeof(int)的数组count[sizeof(int)]，count[i]表示在在i位出现的1的次数。如果count[i]是</span><br><span class="line">// 3的整数倍，则忽略；否则就把该位取出来组成答案。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        const int W = sizeof(int) * 8; // 一个整数的bit数，即整数字长</span><br><span class="line">        int count[W];  // count[i]表示在在i位出现的1的次数</span><br><span class="line">        fill_n(&amp;count[0], W, 0);</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; W; j++) &#123;</span><br><span class="line">                count[j] += (nums[i] &gt;&gt; j) &amp; 1;</span><br><span class="line">                count[j] %= 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i = 0; i &lt; W; i++) &#123;</span><br><span class="line">            result += (count[i] &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Single Number II</span><br><span class="line">// 方法2，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">// 用one记录到当前处理的元素为止，二进制1出现“1次”（mod 3 之后的 1）的有哪些二进制位；用two记录到当前计算</span><br><span class="line">// 的变量为止，二进制1出现“2次”（mod 3 之后的 2）的有哪些二进制位。当one和two中的某一位同时为1时表示该二进</span><br><span class="line">// 制位上1出现了3次，此时需要清零。即用二进制模拟三进制运算。最终one记录的是最终结果。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int one = 0, two = 0, three = 0;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            two |= (one &amp; i);</span><br><span class="line">            one ^= i;</span><br><span class="line">            three = ~(one &amp; two);</span><br><span class="line">            one &amp;= three;</span><br><span class="line">            two &amp;= three;</span><br><span class="line">        &#125;</span><br><span class="line">        return one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-2单链表"><a href="#2-2单链表" class="headerlink" title="2.2单链表"></a>2.2单链表</h3><h4 id="2-2-1给出两个表示两个非负数的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。添加两个数字并将其作为链表返回。输入：（2～4～3）（5～6～4）输出：7～0～8"><a href="#2-2-1给出两个表示两个非负数的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。添加两个数字并将其作为链表返回。输入：（2～4～3）（5～6～4）输出：7～0～8" class="headerlink" title="*2.2.1给出两个表示两个非负数的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。添加两个数字并将其作为链表返回。输入：（2～4～3）（5～6～4）输出：7～0～8"></a>*2.2.1给出两个表示两个非负数的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。添加两个数字并将其作为链表返回。输入：（2～4～3）（5～6～4）输出：7～0～8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Add Two Numbers</span><br><span class="line">// 和 Add Binary 类似</span><br><span class="line">// 时间复杂度O(m+n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123;</span><br><span class="line">        ListNode dummy(-1); // 头节点</span><br><span class="line">        int carry = 0;</span><br><span class="line">        ListNode *prev = &amp;dummy;</span><br><span class="line">        for (ListNode *pa=l1,*pb=l2;pa!=nullptr||pb!=nullptr;pa=pa==nullptr?nullptr:pa-&gt;next,pb=pb==nullptr?nullptr:pb-&gt;next,prev=prev-&gt;next) &#123;</span><br><span class="line">            const int ai = pa == nullptr ? 0 : pa-&gt;val;</span><br><span class="line">            const int bi = pb == nullptr ? 0 : pb-&gt;val;</span><br><span class="line">            const int value = (ai + bi + carry) % 10;</span><br><span class="line">            carry = (ai + bi + carry) / 10;</span><br><span class="line">            prev-&gt;next = new ListNode(value); // 尾插法</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0)</span><br><span class="line">            prev-&gt;next = new ListNode(carry);</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2将链表从位置m反转到N。就地并一次通过。例如：给定1-gt-2-gt-3-gt-4-gt-5-gt-nullptr，m-2，n-4，返回1-gt-4-gt-3-gt-2-gt-5-gt-nullptr。注：给定m，n满足以下条件：1≤m≤n≤长度。"><a href="#2-2-2将链表从位置m反转到N。就地并一次通过。例如：给定1-gt-2-gt-3-gt-4-gt-5-gt-nullptr，m-2，n-4，返回1-gt-4-gt-3-gt-2-gt-5-gt-nullptr。注：给定m，n满足以下条件：1≤m≤n≤长度。" class="headerlink" title="2.2.2将链表从位置m反转到N。就地并一次通过。例如：给定1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr，m=2，n=4，返回1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;nullptr。注：给定m，n满足以下条件：1≤m≤n≤长度。"></a>2.2.2将链表从位置m反转到N。就地并一次通过。例如：给定1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr，m=2，n=4，返回1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;nullptr。注：给定m，n满足以下条件：1≤m≤n≤长度。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Reverse Linked List II</span><br><span class="line">// 迭代版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *reverseBetween(ListNode *head, int m, int n) &#123;</span><br><span class="line">        ListNode dummy(-1);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *prev = &amp;dummy;</span><br><span class="line">        for (int i = 0; i &lt; m-1; ++i)</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        ListNode* const head2 = prev;</span><br><span class="line">        prev = head2-&gt;next;</span><br><span class="line">        ListNode *cur = prev-&gt;next;</span><br><span class="line">        for (int i = m; i &lt; n; ++i) &#123;</span><br><span class="line">            prev-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = head2-&gt;next;</span><br><span class="line">            head2-&gt;next = cur; // 头插法</span><br><span class="line">            cur = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3给定一个链表和一个值x，将其划分为所有小于x的节点都在大于或等于x的节点之前。您应该保持两个分区中节点的原始相对顺序。例如，给定1-gt-4-gt-3-gt-2-gt-5-gt-2和x-3，返回1-gt-2-gt-2-gt-4-gt-3-gt-5。"><a href="#2-2-3给定一个链表和一个值x，将其划分为所有小于x的节点都在大于或等于x的节点之前。您应该保持两个分区中节点的原始相对顺序。例如，给定1-gt-4-gt-3-gt-2-gt-5-gt-2和x-3，返回1-gt-2-gt-2-gt-4-gt-3-gt-5。" class="headerlink" title="2.2.3给定一个链表和一个值x，将其划分为所有小于x的节点都在大于或等于x的节点之前。您应该保持两个分区中节点的原始相对顺序。例如，给定1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2和x=3，返回1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。"></a>2.2.3给定一个链表和一个值x，将其划分为所有小于x的节点都在大于或等于x的节点之前。您应该保持两个分区中节点的原始相对顺序。例如，给定1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2和x=3，返回1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Partition List</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* partition(ListNode* head, int x) &#123;</span><br><span class="line">        ListNode left_dummy(-1); // 头结点</span><br><span class="line">        ListNode right_dummy(-1); // 头结点</span><br><span class="line">        auto left_cur = &amp;left_dummy;</span><br><span class="line">        auto right_cur = &amp;right_dummy;</span><br><span class="line">        for (ListNode *cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val &lt; x) &#123;</span><br><span class="line">                left_cur-&gt;next = cur;</span><br><span class="line">                left_cur = cur;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right_cur-&gt;next = cur;</span><br><span class="line">                right_cur = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left_cur-&gt;next = right_dummy.next;</span><br><span class="line">        right_cur-&gt;next = nullptr;</span><br><span class="line">        return left_dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4给定一个排序链接列表，删除所有重复项，使每个元素只出现一次。例如，给定1-gt-1-gt-2，返回1-gt-2，给定1-gt-1-gt-2-gt-3，返回1-gt-2-gt-3"><a href="#2-3-4给定一个排序链接列表，删除所有重复项，使每个元素只出现一次。例如，给定1-gt-1-gt-2，返回1-gt-2，给定1-gt-1-gt-2-gt-3，返回1-gt-2-gt-3" class="headerlink" title="2.3.4给定一个排序链接列表，删除所有重复项，使每个元素只出现一次。例如，给定1-&gt;1-&gt;2，返回1-&gt;2，给定1-&gt;1-&gt;2-&gt;3，返回1-&gt;2-&gt;3"></a>2.3.4给定一个排序链接列表，删除所有重复项，使每个元素只出现一次。例如，给定1-&gt;1-&gt;2，返回1-&gt;2，给定1-&gt;1-&gt;2-&gt;3，返回1-&gt;2-&gt;3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted List</span><br><span class="line">// 递归版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *deleteDuplicates(ListNode *head) &#123;</span><br><span class="line">        if (!head) return head;</span><br><span class="line">        ListNode dummy(head-&gt;val + 1); // 值只要和head不同即可</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        recur(&amp;dummy, head);</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static void recur(ListNode *prev, ListNode *cur) &#123;</span><br><span class="line">        if (cur == nullptr) return;</span><br><span class="line">        if (prev-&gt;val == cur-&gt;val) &#123; // 删除head</span><br><span class="line">            prev-&gt;next = cur-&gt;next;</span><br><span class="line">            delete cur;</span><br><span class="line">            recur(prev, prev-&gt;next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            recur(prev-&gt;next, cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted List</span><br><span class="line">// 迭代版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *deleteDuplicates(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr) return nullptr;</span><br><span class="line">        for (ListNode *prev = head, *cur = head-&gt;next; cur; cur = prev-&gt;next) &#123;</span><br><span class="line">            if (prev-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">                delete cur;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5给定一个排序链接列表，删除所有重复编号的节点，只从原始列表中留下不同的编号。例如，给定1-gt-2-gt-3-gt-3-gt-4-gt-4-gt-5，返回1-gt-2-gt-5，给定1-gt-1-gt-1-gt-2-gt-3，返回2-gt-3。"><a href="#2-2-5给定一个排序链接列表，删除所有重复编号的节点，只从原始列表中留下不同的编号。例如，给定1-gt-2-gt-3-gt-3-gt-4-gt-4-gt-5，返回1-gt-2-gt-5，给定1-gt-1-gt-1-gt-2-gt-3，返回2-gt-3。" class="headerlink" title="2.2.5给定一个排序链接列表，删除所有重复编号的节点，只从原始列表中留下不同的编号。例如，给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5，返回1-&gt;2-&gt;5，给定1-&gt;1-&gt;1-&gt;2-&gt;3，返回2-&gt;3。"></a>2.2.5给定一个排序链接列表，删除所有重复编号的节点，只从原始列表中留下不同的编号。例如，给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5，返回1-&gt;2-&gt;5，给定1-&gt;1-&gt;1-&gt;2-&gt;3，返回2-&gt;3。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted List II</span><br><span class="line">// 递归版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *deleteDuplicates(ListNode *head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) return head;</span><br><span class="line">        ListNode *p = head-&gt;next;</span><br><span class="line">        if (head-&gt;val == p-&gt;val) &#123;</span><br><span class="line">            while (p &amp;&amp; head-&gt;val == p-&gt;val) &#123;</span><br><span class="line">                ListNode *tmp = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                delete tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            delete head;</span><br><span class="line">            return deleteDuplicates(p);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Duplicates from Sorted List II</span><br><span class="line">// 迭代版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *deleteDuplicates(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr) return head;</span><br><span class="line">        ListNode dummy(INT_MIN); // 头结点</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *prev = &amp;dummy, *cur = head;</span><br><span class="line">        while (cur != nullptr) &#123;</span><br><span class="line">            bool duplicated = false;</span><br><span class="line">            while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                duplicated = true;</span><br><span class="line">                ListNode *temp = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                delete temp;</span><br><span class="line">            &#125;</span><br><span class="line">            if (duplicated) &#123; // 删除重复的最后一个元素</span><br><span class="line">                ListNode *temp = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                delete temp;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;next = cur;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = cur;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6给定一个列表，按k个位置向右旋转列表，其中k是非负的。例如：给定1＞2＞3＞4＞5＞nullptr和k＝2，返回4＞5＞1＞2＞3＞nullptr。"><a href="#2-2-6给定一个列表，按k个位置向右旋转列表，其中k是非负的。例如：给定1＞2＞3＞4＞5＞nullptr和k＝2，返回4＞5＞1＞2＞3＞nullptr。" class="headerlink" title="2.2.6给定一个列表，按k个位置向右旋转列表，其中k是非负的。例如：给定1＞2＞3＞4＞5＞nullptr和k＝2，返回4＞5＞1＞2＞3＞nullptr。"></a>2.2.6给定一个列表，按k个位置向右旋转列表，其中k是非负的。例如：给定1＞2＞3＞4＞5＞nullptr和k＝2，返回4＞5＞1＞2＞3＞nullptr。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Rotate List</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *rotateRight(ListNode *head, int k) &#123;</span><br><span class="line">        if (head == nullptr || k == 0) return head;</span><br><span class="line">        int len = 1;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while (p-&gt;next) &#123; // 求长度</span><br><span class="line">            len++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        k = len - k % len;</span><br><span class="line">        p-&gt;next = head; // 首尾相连</span><br><span class="line">        for(int step = 0; step &lt; k; step++) &#123;</span><br><span class="line">            p = p-&gt;next;  //接着往后跑</span><br><span class="line">        &#125;</span><br><span class="line">        head = p-&gt;next; // 新的首节点</span><br><span class="line">        p-&gt;next = nullptr; // 断开环</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7给定一个链表，从列表的末尾移除第n个节点并返回它的头。例如，给定的链表：1-gt-2-gt-3-gt-4-gt-5，和n-2。在从末尾移除第二个节点后，链接列表变成1-gt-2-gt-3-gt-5。注意：·给定n将始终有效。·尝试在一次传递中这样做。"><a href="#2-2-7给定一个链表，从列表的末尾移除第n个节点并返回它的头。例如，给定的链表：1-gt-2-gt-3-gt-4-gt-5，和n-2。在从末尾移除第二个节点后，链接列表变成1-gt-2-gt-3-gt-5。注意：·给定n将始终有效。·尝试在一次传递中这样做。" class="headerlink" title="2.2.7给定一个链表，从列表的末尾移除第n个节点并返回它的头。例如，给定的链表：1-&gt;2-&gt;3-&gt;4-&gt;5，和n=2。在从末尾移除第二个节点后，链接列表变成1-&gt;2-&gt;3-&gt;5。注意：·给定n将始终有效。·尝试在一次传递中这样做。"></a>2.2.7给定一个链表，从列表的末尾移除第n个节点并返回它的头。例如，给定的链表：1-&gt;2-&gt;3-&gt;4-&gt;5，和n=2。在从末尾移除第二个节点后，链接列表变成1-&gt;2-&gt;3-&gt;5。注意：·给定n将始终有效。·尝试在一次传递中这样做。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Remove Nth Node From End of List</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *removeNthFromEnd(ListNode *head, int n) &#123;</span><br><span class="line">        ListNode dummy&#123;-1, head&#125;;</span><br><span class="line">        ListNode *p = &amp;dummy, *q = &amp;dummy;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)  // q先走n步</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        while(q-&gt;next) &#123; // 一起走</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tmp = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        delete tmp;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-8给定一个链表，每两个相邻的节点交换一次，然后返回它的头。例如，给定1-gt-2-gt-3-gt-4，您应该将列表返回为2-gt-1-gt-4-gt-3。您的算法应该只使用常量空间。您可以不修改列表中的值，只能更改节点本身。"><a href="#2-2-8给定一个链表，每两个相邻的节点交换一次，然后返回它的头。例如，给定1-gt-2-gt-3-gt-4，您应该将列表返回为2-gt-1-gt-4-gt-3。您的算法应该只使用常量空间。您可以不修改列表中的值，只能更改节点本身。" class="headerlink" title="2.2.8给定一个链表，每两个相邻的节点交换一次，然后返回它的头。例如，给定1-&gt;2-&gt;3-&gt;4，您应该将列表返回为2-&gt;1-&gt;4-&gt;3。您的算法应该只使用常量空间。您可以不修改列表中的值，只能更改节点本身。"></a>2.2.8给定一个链表，每两个相邻的节点交换一次，然后返回它的头。例如，给定1-&gt;2-&gt;3-&gt;4，您应该将列表返回为2-&gt;1-&gt;4-&gt;3。您的算法应该只使用常量空间。您可以不修改列表中的值，只能更改节点本身。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Swap Nodes in Pairs</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *swapPairs(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) return head;</span><br><span class="line">        ListNode dummy(-1);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        for(ListNode *prev = &amp;dummy, *cur = prev-&gt;next, *next = cur-&gt;next;</span><br><span class="line">                next;</span><br><span class="line">                prev = cur, cur = cur-&gt;next, next = cur ? cur-&gt;next: nullptr) &#123;</span><br><span class="line">            prev-&gt;next = next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-9给定一个链表，一次倒转链表k的节点并返回其修改后的列表。如果节点数不是k的倍数，那么最后的退出节点应该保持原样。您可以不改变节点中的值，只能更改节点本身。只分配常量内存。例如，给定这个链接列表：1-gt-2-gt-3-gt-4-gt-5：K-2，你应该返回：2-gt-1-gt-4-gt-3-gt-5；k-3，你应该返回：3-gt-2-gt-1-gt-4-gt-5"><a href="#2-2-9给定一个链表，一次倒转链表k的节点并返回其修改后的列表。如果节点数不是k的倍数，那么最后的退出节点应该保持原样。您可以不改变节点中的值，只能更改节点本身。只分配常量内存。例如，给定这个链接列表：1-gt-2-gt-3-gt-4-gt-5：K-2，你应该返回：2-gt-1-gt-4-gt-3-gt-5；k-3，你应该返回：3-gt-2-gt-1-gt-4-gt-5" class="headerlink" title="2.2.9给定一个链表，一次倒转链表k的节点并返回其修改后的列表。如果节点数不是k的倍数，那么最后的退出节点应该保持原样。您可以不改变节点中的值，只能更改节点本身。只分配常量内存。例如，给定这个链接列表：1-&gt;2-&gt;3-&gt;4-&gt;5：K=2，你应该返回：2-&gt;1-&gt;4-&gt;3-&gt;5；k=3，你应该返回：3-&gt;2-&gt;1-&gt;4-&gt;5"></a>2.2.9给定一个链表，一次倒转链表k的节点并返回其修改后的列表。如果节点数不是k的倍数，那么最后的退出节点应该保持原样。您可以不改变节点中的值，只能更改节点本身。只分配常量内存。例如，给定这个链接列表：1-&gt;2-&gt;3-&gt;4-&gt;5：K=2，你应该返回：2-&gt;1-&gt;4-&gt;3-&gt;5；k=3，你应该返回：3-&gt;2-&gt;1-&gt;4-&gt;5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Reverse Nodes in k-Group</span><br><span class="line">// 递归版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *reverseKGroup(ListNode *head, int k) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr || k &lt; 2)</span><br><span class="line">            return head;</span><br><span class="line">        ListNode *next_group = head;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            if (next_group)</span><br><span class="line">                next_group = next_group-&gt;next;</span><br><span class="line">            else</span><br><span class="line">                return head;</span><br><span class="line">        &#125;</span><br><span class="line">        // next_group is the head of next group</span><br><span class="line">        // new_next_group is the new head of next group after reversion</span><br><span class="line">        ListNode *new_next_group = reverseKGroup(next_group, k);</span><br><span class="line">        ListNode *prev = NULL, *cur = head;</span><br><span class="line">        while (cur != next_group) &#123;</span><br><span class="line">            ListNode *next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev ? prev : new_next_group;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev; // prev will be the new head of this group</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Reverse Nodes in k-Group</span><br><span class="line">// 迭代版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *reverseKGroup(ListNode *head, int k) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr || k &lt; 2) return head;</span><br><span class="line">        ListNode dummy(-1);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        for(ListNode *prev = &amp;dummy, *end = head; end; end = prev-&gt;next) &#123;</span><br><span class="line">            for (int i = 1; i &lt; k &amp;&amp; end; i++)</span><br><span class="line">                end = end-&gt;next;</span><br><span class="line">            if (end  == nullptr) break;  // 不足 k 个</span><br><span class="line"></span><br><span class="line">            prev = reverse(prev, prev-&gt;next, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    // prev 是 first 前一个元素, [begin, end] 闭区间，保证三者都不为 null</span><br><span class="line">    // 返回反转后的倒数第1个元素</span><br><span class="line">    ListNode* reverse(ListNode *prev, ListNode *begin, ListNode *end) &#123;</span><br><span class="line">        ListNode *end_next = end-&gt;next;</span><br><span class="line">        for (ListNode *p = begin, *cur = p-&gt;next, *next = cur-&gt;next;</span><br><span class="line">                cur != end_next;</span><br><span class="line">                p = cur, cur = next, next = next ? next-&gt;next : nullptr) &#123;</span><br><span class="line">            cur-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        begin-&gt;next = end_next;</span><br><span class="line">        prev-&gt;next = end;</span><br><span class="line">        return begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-10给出一个链表，使每个节点包含一个额外的随机指针，该指针可以指向列表中的任何节点或空。返回列表的深度副本。"><a href="#2-2-10给出一个链表，使每个节点包含一个额外的随机指针，该指针可以指向列表中的任何节点或空。返回列表的深度副本。" class="headerlink" title="2.2.10给出一个链表，使每个节点包含一个额外的随机指针，该指针可以指向列表中的任何节点或空。返回列表的深度副本。"></a>2.2.10给出一个链表，使每个节点包含一个额外的随机指针，该指针可以指向列表中的任何节点或空。返回列表的深度副本。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-2-11给出一个链表，确定它是否有一个循环。跟进：你能不用额外的空间来解决它吗？"><a href="#2-2-11给出一个链表，确定它是否有一个循环。跟进：你能不用额外的空间来解决它吗？" class="headerlink" title="2.2.11给出一个链表，确定它是否有一个循环。跟进：你能不用额外的空间来解决它吗？"></a>2.2.11给出一个链表，确定它是否有一个循环。跟进：你能不用额外的空间来解决它吗？</h4><p>最好的方法是时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>的。设置两个指针，一个快一个慢，快的指针每次走两步，慢的指针每次走一步，如果快指针和慢指针相遇，则说明有环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode, Linked List Cycle</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        // 设置两个指针，一个快一个慢</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (slow == fast) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-12给定一个链接列表，返回循环开始的节点。如果没有循环，返回空。后续：您可以不使用额外的空间来解决它吗？"><a href="#2-2-12给定一个链接列表，返回循环开始的节点。如果没有循环，返回空。后续：您可以不使用额外的空间来解决它吗？" class="headerlink" title="2.2.12给定一个链接列表，返回循环开始的节点。如果没有循环，返回空。后续：您可以不使用额外的空间来解决它吗？"></a>2.2.12给定一个链接列表，返回循环开始的节点。如果没有循环，返回空。后续：您可以不使用额外的空间来解决它吗？</h4><p>当fast与slow相遇时，slow肯定没有遍历完链表，而fast已经在环内循环了<code>n</code>圈(<code>1 &lt;= n</code>)。假设slow走了<code>s</code>步，则fast走了<code>2s</code>步（fast步数还等于<code>s</code>加上在环上多转的<code>n</code>圈），设环长为<code>r</code>，则：<br><code>2s = s + nr</code><br><code>s = nr</code></p>
<p>设整个链表长<code>L</code>，环入口点与相遇点距离为<code>a</code>，起点到环入口点的距离为<code>x</code>，则<br><code>x + a = nr = (n – 1)r +r = (n-1)r + L - x</code><br><code>x = (n-1)r + (L – x – a)</code></p>
<p><code>L – x – a</code>为相遇点到环入口点的距离，由此可知，从链表头到环入口点等于<code>n-1</code>圈内环+相遇点到环入口点，于是我们可以从<code>head</code>开始另设一个指针<code>slow2</code>，两个慢指针每次前进一步，它俩一定会在环入口点相遇。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode, Linked List Cycle II</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                ListNode *slow2 = head;</span><br><span class="line">                while (slow2 != slow) &#123;</span><br><span class="line">                    slow2 = slow2-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return slow2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-13给定一个单链接列表l：L0-gt-L1-gt-··-gt-Ln−1-gt-Ln，将其重新排序为：L0-gt-Ln-gt-L1-gt-Ln-1-gt-L2-gt-Ln−2-gt-···您必须在不改变节点值的情况下执行此操作。例如，给定-1，2，3，4-，将其重新排序为-1，4，2，3-。"><a href="#2-2-13给定一个单链接列表l：L0-gt-L1-gt-··-gt-Ln−1-gt-Ln，将其重新排序为：L0-gt-Ln-gt-L1-gt-Ln-1-gt-L2-gt-Ln−2-gt-···您必须在不改变节点值的情况下执行此操作。例如，给定-1，2，3，4-，将其重新排序为-1，4，2，3-。" class="headerlink" title="2.2.13给定一个单链接列表l：L0-&gt;L1-&gt;··-&gt;Ln−1-&gt;Ln，将其重新排序为：L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln−2-&gt;···您必须在不改变节点值的情况下执行此操作。例如，给定{1，2，3，4}，将其重新排序为{1，4，2，3}。"></a>2.2.13给定一个单链接列表l：L0-&gt;L1-&gt;··-&gt;Ln−1-&gt;Ln，将其重新排序为：L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln−2-&gt;···您必须在不改变节点值的情况下执行此操作。例如，给定{1，2，3，4}，将其重新排序为{1，4，2，3}。</h4><p>题目规定要<code>in-place</code>，也就是说只能使用<code>O(1)</code>的空间。</p>
<p>可以找到中间节点，断开，把后半截单链表<code>reverse</code>一下，再合并两个单链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Reorder List</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reorderList(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) return;</span><br><span class="line">        ListNode *slow = head, *fast = head, *prev = nullptr;</span><br><span class="line">        while (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = nullptr; // cut at middle</span><br><span class="line">        slow = reverse(slow);</span><br><span class="line">        // merge two lists</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        while (curr-&gt;next) &#123;</span><br><span class="line">            ListNode *tmp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            curr-&gt;next-&gt;next = tmp;</span><br><span class="line">            curr = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;next = slow;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* reverse(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) return head;</span><br><span class="line">        ListNode *prev = head;</span><br><span class="line">        for (ListNode *curr = head-&gt;next, *next = curr-&gt;next; curr;</span><br><span class="line">            prev = curr, curr = next, next = next ? next-&gt;next : nullptr) &#123;</span><br><span class="line">                curr-&gt;next = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-14为最近使用最少的-LRU-缓存设计和实现一个数据结构。它应该支持以下操作：get和set。get-key-如果键存在于缓存中，则获取键的值-始终为正-，否则返回-1-set-key，value-如果密钥尚未显示，则设置或插入值。当缓存达到其容量时，它应该在插入新项之前使最近使用最少的项无效。"><a href="#2-2-14为最近使用最少的-LRU-缓存设计和实现一个数据结构。它应该支持以下操作：get和set。get-key-如果键存在于缓存中，则获取键的值-始终为正-，否则返回-1-set-key，value-如果密钥尚未显示，则设置或插入值。当缓存达到其容量时，它应该在插入新项之前使最近使用最少的项无效。" class="headerlink" title="2.2.14为最近使用最少的(LRU)缓存设计和实现一个数据结构。它应该支持以下操作：get和set。get(key)-如果键存在于缓存中，则获取键的值(始终为正)，否则返回-1.set(key，value)-如果密钥尚未显示，则设置或插入值。当缓存达到其容量时，它应该在插入新项之前使最近使用最少的项无效。"></a>2.2.14为最近使用最少的(LRU)缓存设计和实现一个数据结构。它应该支持以下操作：get和set。get(key)-如果键存在于缓存中，则获取键的值(始终为正)，否则返回-1.set(key，value)-如果密钥尚未显示，则设置或插入值。当缓存达到其容量时，它应该在插入新项之前使最近使用最少的项无效。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, LRU Cache</span><br><span class="line">// 时间复杂度O(logn)，空间复杂度O(n)</span><br><span class="line">class LRUCache&#123;</span><br><span class="line">private:</span><br><span class="line">    struct CacheNode &#123;</span><br><span class="line">        int key;</span><br><span class="line">        int value;</span><br><span class="line">        CacheNode(int k, int v) :key(k), value(v)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        this-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (cacheMap.find(key) == cacheMap.end()) return -1;</span><br><span class="line">        // 把当前访问的节点移到链表头部，并且更新map中该节点的地址</span><br><span class="line">        cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]); </span><br><span class="line">        cacheMap[key] = cacheList.begin();</span><br><span class="line">        return cacheMap[key]-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    void set(int key, int value) &#123;</span><br><span class="line">        if (cacheMap.find(key) == cacheMap.end()) &#123;</span><br><span class="line">            if (cacheList.size() == capacity) &#123; //删除链表尾部节点（最少访问的节点）</span><br><span class="line">                cacheMap.erase(cacheList.back().key);</span><br><span class="line">                cacheList.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            // 插入新节点到链表头部, 并且在map中增加该节点</span><br><span class="line">            cacheList.push_front(CacheNode(key, value));</span><br><span class="line">            cacheMap[key] = cacheList.begin();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //更新节点的值，把当前访问的节点移到链表头部,并且更新map中该节点的地址</span><br><span class="line">            cacheMap[key]-&gt;value = value;</span><br><span class="line">            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);</span><br><span class="line">            cacheMap[key] = cacheList.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    list&lt;CacheNode&gt; cacheList;</span><br><span class="line">    unordered_map&lt;int, list&lt;CacheNode&gt;::iterator&gt; cacheMap;</span><br><span class="line">    int capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3字符串"><a href="#3字符串" class="headerlink" title="3字符串"></a>3字符串</h3><h4 id="3-1给定一个字符串，确定它是否是回文，只考虑字母数字字符，忽略情况。例如，“A-man-a-plan-a-canal-Panama”是回文。“race-a-car”不是回文。注意：你认为字符串可能是空的吗？这是一个很好的问题，在面试时可以问。为了解决这个问题，我们把空字符串定义为有效的回文。–125"><a href="#3-1给定一个字符串，确定它是否是回文，只考虑字母数字字符，忽略情况。例如，“A-man-a-plan-a-canal-Panama”是回文。“race-a-car”不是回文。注意：你认为字符串可能是空的吗？这是一个很好的问题，在面试时可以问。为了解决这个问题，我们把空字符串定义为有效的回文。–125" class="headerlink" title="3.1给定一个字符串，确定它是否是回文，只考虑字母数字字符，忽略情况。例如，“A man, a plan, a canal: Panama”是回文。“race a car”不是回文。注意：你认为字符串可能是空的吗？这是一个很好的问题，在面试时可以问。为了解决这个问题，我们把空字符串定义为有效的回文。–125"></a>3.1给定一个字符串，确定它是否是回文，只考虑字母数字字符，忽略情况。例如，“A man, a plan, a canal: Panama”是回文。“race a car”不是回文。注意：你认为字符串可能是空的吗？这是一个很好的问题，在面试时可以问。为了解决这个问题，我们把空字符串定义为有效的回文。–125</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Leet Code, Valid Palindrome</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string s) &#123;</span><br><span class="line">        transform(s.begin(), s.end(), s.begin(), ::tolower);</span><br><span class="line">        auto left = s.begin(), right = prev(s.end());</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (!::isalnum(*left)) ++left;</span><br><span class="line">            else if (!::isalnum(*right)) --right;</span><br><span class="line">            else if (*left != *right) return false;</span><br><span class="line">            else &#123; left++, right--; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string s) &#123;</span><br><span class="line">        int left = 0, right = s.size() - 1 ;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (!isalnum(s[left])) ++left;</span><br><span class="line">            else if (!isalnum(s[right])) --right;</span><br><span class="line">            else if ((s[left] + 32 - &apos;a&apos;) %32 != (s[right] + 32 - &apos;a&apos;) % 32) return false;</span><br><span class="line">            else &#123;</span><br><span class="line">                ++left; --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-2实现strStr-。返回一个指针，指向haystack中needle的第一次出现，如果needle不是haystack的一部分，则为NULL。–28"><a href="#3-2实现strStr-。返回一个指针，指向haystack中needle的第一次出现，如果needle不是haystack的一部分，则为NULL。–28" class="headerlink" title="3.2实现strStr()。返回一个指针，指向haystack中needle的第一次出现，如果needle不是haystack的一部分，则为NULL。–28"></a>3.2实现strStr()。返回一个指针，指向haystack中needle的第一次出现，如果needle不是haystack的一部分，则为NULL。–28</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if (needle.empty()) return 0;</span><br><span class="line">        int m = haystack.size(), n = needle.size();</span><br><span class="line">        if (m &lt; n) return -1;</span><br><span class="line">        for (int i = 0; i &lt;= m - n; ++i) &#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for (j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (haystack[i + j] != needle[j]) break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == n) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-3实现atoi将字符串转换为整数。提示：仔细考虑所有可能的输入情况。如果您想要询问，请不要看到下面的问题，并问自己可能的输入用例是什么。注意：这个问题的目的是模糊地指定-即，没有给定的输入规格-。您负责收集所有的输入要求。在找到第一个非空格字符之前，尽可能多地使用空格字符。然后，从这个字符开始，取一个可选的正负号，后面跟着尽可能多的数字，并将它们解释为一个数值。字符串可以在构成整数的字符之后包含其他字符，这些字符被忽略，对此函数的行为没有任何影响。如果str中的第一个非空白字符序列不是有效整数，或者由于str为空或它只包含空白字符而不存在这种序列，则不进行转换。如果无法执行有效的转换，则返回一个零值。如果正确的值超出可表示值的范围，则返回int-max-2147483647-或int-min-2147483648-。"><a href="#3-3实现atoi将字符串转换为整数。提示：仔细考虑所有可能的输入情况。如果您想要询问，请不要看到下面的问题，并问自己可能的输入用例是什么。注意：这个问题的目的是模糊地指定-即，没有给定的输入规格-。您负责收集所有的输入要求。在找到第一个非空格字符之前，尽可能多地使用空格字符。然后，从这个字符开始，取一个可选的正负号，后面跟着尽可能多的数字，并将它们解释为一个数值。字符串可以在构成整数的字符之后包含其他字符，这些字符被忽略，对此函数的行为没有任何影响。如果str中的第一个非空白字符序列不是有效整数，或者由于str为空或它只包含空白字符而不存在这种序列，则不进行转换。如果无法执行有效的转换，则返回一个零值。如果正确的值超出可表示值的范围，则返回int-max-2147483647-或int-min-2147483648-。" class="headerlink" title="3.3实现atoi将字符串转换为整数。提示：仔细考虑所有可能的输入情况。如果您想要询问，请不要看到下面的问题，并问自己可能的输入用例是什么。注意：这个问题的目的是模糊地指定(即，没有给定的输入规格)。您负责收集所有的输入要求。在找到第一个非空格字符之前，尽可能多地使用空格字符。然后，从这个字符开始，取一个可选的正负号，后面跟着尽可能多的数字，并将它们解释为一个数值。字符串可以在构成整数的字符之后包含其他字符，这些字符被忽略，对此函数的行为没有任何影响。如果str中的第一个非空白字符序列不是有效整数，或者由于str为空或它只包含空白字符而不存在这种序列，则不进行转换。如果无法执行有效的转换，则返回一个零值。如果正确的值超出可表示值的范围，则返回int_max(2147483647)或int_min(-2147483648)。"></a>3.3实现<code>atoi</code>将字符串转换为整数。提示：仔细考虑所有可能的输入情况。如果您想要询问，请不要看到下面的问题，并问自己可能的输入用例是什么。注意：这个问题的目的是模糊地指定(即，没有给定的输入规格)。您负责收集所有的输入要求。在找到第一个非空格字符之前，尽可能多地使用空格字符。然后，从这个字符开始，取一个可选的正负号，后面跟着尽可能多的数字，并将它们解释为一个数值。字符串可以在构成整数的字符之后包含其他字符，这些字符被忽略，对此函数的行为没有任何影响。如果<code>str</code>中的第一个非空白字符序列不是有效整数，或者由于<code>str</code>为空或它只包含空白字符而不存在这种序列，则不进行转换。如果无法执行有效的转换，则返回一个零值。如果正确的值超出可表示值的范围，则返回<code>int_max(2147483647)</code>或<code>int_min(-2147483648)</code>。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, String to Integer (atoi)</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(const string &amp;str) &#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int sign = 1;</span><br><span class="line">        const int n = str.length();</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (str[i] == &apos; &apos; &amp;&amp; i &lt; n) i++;</span><br><span class="line">        if (str[i] == &apos;+&apos;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (str[i] == &apos;-&apos;) &#123;</span><br><span class="line">            sign = -1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; i &lt; n; i++) &#123;</span><br><span class="line">            if (str[i] &lt; &apos;0&apos; || str[i] &gt; &apos;9&apos;)</span><br><span class="line">                break;</span><br><span class="line">            if (num &gt; INT_MAX / 10 ||</span><br><span class="line">                            (num == INT_MAX / 10 &amp;&amp;</span><br><span class="line">                                    (str[i] - &apos;0&apos;) &gt; INT_MAX % 10)) &#123;</span><br><span class="line">                return sign == -1 ? INT_MIN : INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * 10 + str[i] - &apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return num * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-4给定两个二进制字符串，返回它们的和-也是二进制字符串-。例如，a-”11”b-”1”返回”100”。"><a href="#3-4给定两个二进制字符串，返回它们的和-也是二进制字符串-。例如，a-”11”b-”1”返回”100”。" class="headerlink" title="3.4给定两个二进制字符串，返回它们的和(也是二进制字符串)。例如，a=”11”b=”1”返回”100”。"></a>3.4给定两个二进制字符串，返回它们的和(也是二进制字符串)。例如，a=”11”b=”1”返回”100”。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Add Binary</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        string result;</span><br><span class="line">        const size_t n = a.size() &gt; b.size() ? a.size() : b.size();</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        reverse(b.begin(), b.end());</span><br><span class="line">        int carry = 0;</span><br><span class="line">        for (size_t i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            const int ai = i &lt; a.size() ? a[i] - &apos;0&apos; : 0;</span><br><span class="line">            const int bi = i &lt; b.size() ? b[i] - &apos;0&apos; : 0;</span><br><span class="line">            const int val = (ai + bi + carry) % 2;</span><br><span class="line">            carry = (ai + bi + carry) / 2;</span><br><span class="line">            result.insert(result.begin(), val + &apos;0&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry == 1) &#123;</span><br><span class="line">            result.insert(result.begin(), &apos;1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-5给定一个字符串S，查找S中最长的回文子字符串，您可能假设s的最大长度为1000，并且存在一个唯一的最长回文子字符串。"><a href="#3-5给定一个字符串S，查找S中最长的回文子字符串，您可能假设s的最大长度为1000，并且存在一个唯一的最长回文子字符串。" class="headerlink" title="3.5给定一个字符串S，查找S中最长的回文子字符串，您可能假设s的最大长度为1000，并且存在一个唯一的最长回文子字符串。"></a>3.5给定一个字符串S，查找S中最长的回文子字符串，您可能假设s的最大长度为1000，并且存在一个唯一的最长回文子字符串。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Palindromic Substring</span><br><span class="line">// 备忘录法，会超时</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(n^2)</span><br><span class="line">typedef string::const_iterator Iterator;</span><br><span class="line">namespace std &#123;</span><br><span class="line">    template&lt;&gt;</span><br><span class="line">    struct hash&lt;pair&lt;Iterator, Iterator&gt;&gt; &#123;</span><br><span class="line">        size_t operator()(pair&lt;Iterator, Iterator&gt; const&amp; p) const &#123;</span><br><span class="line">            return ((size_t) &amp;(*p.first)) ^ ((size_t) &amp;(*p.second));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string const&amp; s) &#123;</span><br><span class="line">        cache.clear();</span><br><span class="line">        return cachedLongestPalindrome(s.begin(), s.end());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;pair&lt;Iterator, Iterator&gt;, string&gt; cache;</span><br><span class="line">    string longestPalindrome(Iterator first, Iterator last) &#123;</span><br><span class="line">        size_t length = distance(first, last);</span><br><span class="line">        if (length &lt; 2) return string(first, last);</span><br><span class="line">        auto s = cachedLongestPalindrome(next(first), prev(last));</span><br><span class="line">        if (s.length() == length - 2 &amp;&amp; *first == *prev(last))</span><br><span class="line">            return string(first, last);</span><br><span class="line">        auto s1 = cachedLongestPalindrome(next(first), last);</span><br><span class="line">        auto s2 = cachedLongestPalindrome(first, prev(last));</span><br><span class="line">        // return max(s, s1, s2)</span><br><span class="line">        if (s.size() &gt; s1.size()) return s.size() &gt; s2.size() ? s : s2;</span><br><span class="line">        else return s1.size() &gt; s2.size() ? s1 : s2;</span><br><span class="line">    &#125;</span><br><span class="line">    string cachedLongestPalindrome(Iterator first, Iterator last) &#123;</span><br><span class="line">        auto key = make_pair(first, last);</span><br><span class="line">        auto pos = cache.find(key);</span><br><span class="line">        if (pos != cache.end()) return pos-&gt;second;</span><br><span class="line">        else return cache[key] = longestPalindrome(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Palindromic Substring</span><br><span class="line">// 动规，时间复杂度O(n^2)，空间复杂度O(n^2)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(const string&amp; s) &#123;</span><br><span class="line">        const int n = s.size();</span><br><span class="line">        bool f[n][n];</span><br><span class="line">        fill_n(&amp;f[0][0], n * n, false);</span><br><span class="line">        // 用 vector 会超时</span><br><span class="line">        //vector&lt;vector&lt;bool&gt; &gt; f(n, vector&lt;bool&gt;(n, false));</span><br><span class="line">        size_t max_len = 1, start = 0;  // 最长回文子串的长度，起点</span><br><span class="line">        for (size_t i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            f[i][i] = true;</span><br><span class="line">            for (size_t j = 0; j &lt; i; j++) &#123;  // [j, i]</span><br><span class="line">                f[j][i] = (s[j] == s[i] &amp;&amp; (i - j &lt; 2 || f[j + 1][i - 1]));</span><br><span class="line">                if (f[j][i] &amp;&amp; max_len &lt; (i - j + 1)) &#123;</span><br><span class="line">                    max_len = i - j + 1;</span><br><span class="line">                    start = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Palindromic Substring</span><br><span class="line">// Manacher’s Algorithm</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Transform S into T.</span><br><span class="line">    // For example, S = &quot;abba&quot;, T = &quot;^#a#b#b#a#$&quot;.</span><br><span class="line">    // ^ and $ signs are sentinels appended to each end to avoid bounds checking</span><br><span class="line">    string preProcess(const string&amp; s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n == 0) return &quot;^$&quot;;</span><br><span class="line">        string ret = &quot;^&quot;;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) ret += &quot;#&quot; + s.substr(i, 1);</span><br><span class="line">        ret += &quot;#$&quot;;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        string T = preProcess(s);</span><br><span class="line">        const int n = T.length();</span><br><span class="line">        // 以T[i]为中心，向左/右扩张的长度，不包含T[i]自己，</span><br><span class="line">        // 因此 P[i]是源字符串中回文串的长度</span><br><span class="line">        int P[n];</span><br><span class="line">        int C = 0, R = 0;</span><br><span class="line">        for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">            int i_mirror = 2 * C - i; // equals to i&apos; = C - (i-C)</span><br><span class="line">            P[i] = (R &gt; i) ? min(R - i, P[i_mirror]) : 0;</span><br><span class="line">            // Attempt to expand palindrome centered at i</span><br><span class="line">            while (T[i + 1 + P[i]] == T[i - 1 - P[i]])</span><br><span class="line">                P[i]++;</span><br><span class="line">            // If palindrome centered at i expand past R,</span><br><span class="line">            // adjust center based on expanded palindrome.</span><br><span class="line">            if (i + P[i] &gt; R) &#123;</span><br><span class="line">                C = i;</span><br><span class="line">                R = i + P[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Find the maximum element in P.</span><br><span class="line">        int max_len = 0;</span><br><span class="line">        int center_index = 0;</span><br><span class="line">        for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">            if (P[i] &gt; max_len) &#123;</span><br><span class="line">                max_len = P[i];</span><br><span class="line">                center_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr((center_index - 1 - max_len) / 2, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-6实现正则表达式匹配，支持”-”和”-“。”-”匹配任何单个字符。”-“匹配前一个元素中的零或多个。匹配应该涵盖整个输入字符串-而不是部分-。函数原型应该是：Bool-isMatch-Const-char-s，Const-char-p-一些示例：isMatch-“aa”，”a”-→false-isMatch-“aa”，”aa”-→true-isMatch-“aaa”，”aa”-→false-isMatch-“aa”，”a-“-→true-isMatch-“aa”，”-“-→trueISMatch-“ab”，”-“-→true-isMatch-“aAB”，”c-a-b”-→true"><a href="#3-6实现正则表达式匹配，支持”-”和”-“。”-”匹配任何单个字符。”-“匹配前一个元素中的零或多个。匹配应该涵盖整个输入字符串-而不是部分-。函数原型应该是：Bool-isMatch-Const-char-s，Const-char-p-一些示例：isMatch-“aa”，”a”-→false-isMatch-“aa”，”aa”-→true-isMatch-“aaa”，”aa”-→false-isMatch-“aa”，”a-“-→true-isMatch-“aa”，”-“-→trueISMatch-“ab”，”-“-→true-isMatch-“aAB”，”c-a-b”-→true" class="headerlink" title="3.6实现正则表达式匹配，支持”.”和”*“。”.”匹配任何单个字符。”*“匹配前一个元素中的零或多个。匹配应该涵盖整个输入字符串(而不是部分)。函数原型应该是：Bool isMatch(Const char*s，Const char*p)一些示例：isMatch(“aa”，”a”)→false isMatch(“aa”，”aa”)→true isMatch(“aaa”，”aa”)→false isMatch(“aa”，”a*“)→true isMatch(“aa”，”.*“)→trueISMatch(“ab”，”.*“)→true isMatch(“aAB”，”c*a*b”)→true"></a>3.6实现正则表达式匹配，支持”.”和”*“。”.”匹配任何单个字符。”*“匹配前一个元素中的零或多个。匹配应该涵盖整个输入字符串(而不是部分)。函数原型应该是：Bool isMatch(Const char*s，Const char*p)一些示例：isMatch(“aa”，”a”)→false isMatch(“aa”，”aa”)→true isMatch(“aaa”，”aa”)→false isMatch(“aa”，”a*“)→true isMatch(“aa”，”.*“)→trueISMatch(“ab”，”.*“)→true isMatch(“aAB”，”c*a*b”)→true</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Regular Expression Matching</span><br><span class="line">// 递归版，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(const string&amp; s, const string&amp; p) &#123;</span><br><span class="line">        return isMatch(s.c_str(), p.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool isMatch(const char *s, const char *p) &#123;</span><br><span class="line">        if (*p == &apos;\0&apos;) return *s == &apos;\0&apos;;</span><br><span class="line">        // next char is not &apos;*&apos;, then must match current character</span><br><span class="line">        if (*(p + 1) != &apos;*&apos;) &#123;</span><br><span class="line">            if (*p == *s || (*p == &apos;.&apos; &amp;&amp; *s != &apos;\0&apos;))</span><br><span class="line">                return isMatch(s + 1, p + 1);</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125; else &#123; // next char is &apos;*&apos;</span><br><span class="line">            while (*p == *s || (*p == &apos;.&apos; &amp;&amp; *s != &apos;\0&apos;)) &#123;</span><br><span class="line">                if (isMatch(s, p + 2))</span><br><span class="line">                    return true;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            return isMatch(s, p + 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-7实现通配符模式匹配，并支持”？”和”-“。”-“匹配任何字符序列-包括空序列-。匹配应该覆盖整个输入字符串-而不是部分-。函数原型应该是：bool-isMatch-const-char-s，const-char-p-一些示例：isMatch-“aa”，”a”-→false-isMatch-“aa”，”aa”-→true-isMatch-“aaa”，”aa”-→false-isMatch-“aa”，”-“-→true-isMatch-“aa”，”a-“-→true-isMatch-“ab”，”？-“-→true-isMatch-“aAB”，”c-a-b”-→false"><a href="#3-7实现通配符模式匹配，并支持”？”和”-“。”-“匹配任何字符序列-包括空序列-。匹配应该覆盖整个输入字符串-而不是部分-。函数原型应该是：bool-isMatch-const-char-s，const-char-p-一些示例：isMatch-“aa”，”a”-→false-isMatch-“aa”，”aa”-→true-isMatch-“aaa”，”aa”-→false-isMatch-“aa”，”-“-→true-isMatch-“aa”，”a-“-→true-isMatch-“ab”，”？-“-→true-isMatch-“aAB”，”c-a-b”-→false" class="headerlink" title="3.7实现通配符模式匹配，并支持”？”和”*“。”*“匹配任何字符序列(包括空序列)。匹配应该覆盖整个输入字符串(而不是部分)。函数原型应该是：bool isMatch(const char*s，const char*p)一些示例：isMatch(“aa”，”a”)→false isMatch(“aa”，”aa”)→true isMatch(“aaa”，”aa”)→false isMatch(“aa”，”*“)→true isMatch(“aa”，”a*“)→true isMatch(“ab”，”？*“)→true isMatch(“aAB”，”c*a*b”)→false"></a>3.7实现通配符模式匹配，并支持”？”和”*“。”*“匹配任何字符序列(包括空序列)。匹配应该覆盖整个输入字符串(而不是部分)。函数原型应该是：bool isMatch(const char*s，const char*p)一些示例：isMatch(“aa”，”a”)→false isMatch(“aa”，”aa”)→true isMatch(“aaa”，”aa”)→false isMatch(“aa”，”*“)→true isMatch(“aa”，”a*“)→true isMatch(“ab”，”？*“)→true isMatch(“aAB”，”c*a*b”)→false</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Wildcard Matching</span><br><span class="line">// 递归版，会超时，用于帮助理解题意</span><br><span class="line">// 时间复杂度O(n!*m!)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(const string&amp; s, const string&amp; p) &#123;</span><br><span class="line">        return isMatch(s.c_str(), p.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool isMatch(const char *s, const char *p) &#123;</span><br><span class="line">        if (*p == &apos;*&apos;) &#123;</span><br><span class="line">            while (*p == &apos;*&apos;) ++p;  //skip continuous &apos;*&apos;</span><br><span class="line">            if (*p == &apos;\0&apos;) return true;</span><br><span class="line">            while (*s != &apos;\0&apos; &amp;&amp; !isMatch(s, p)) ++s;</span><br><span class="line">            return *s != &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (*p == &apos;\0&apos; || *s == &apos;\0&apos;) return *p == *s;</span><br><span class="line">        else if (*p == *s || *p == &apos;?&apos;) return isMatch(++s, ++p);</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Wildcard Matching</span><br><span class="line">// 迭代版，时间复杂度O(n*m)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(const string&amp; s, const string&amp; p) &#123;</span><br><span class="line">        return isMatch(s.c_str(), p.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool isMatch(const char *s, const char *p) &#123;</span><br><span class="line">        bool star = false;</span><br><span class="line">        const char *str, *ptr;</span><br><span class="line">        for (str = s, ptr = p; *str != &apos;\0&apos;; str++, ptr++) &#123;</span><br><span class="line">            switch (*ptr) &#123;</span><br><span class="line">            case &apos;?&apos;:</span><br><span class="line">                break;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                star = true;</span><br><span class="line">                s = str, p = ptr;</span><br><span class="line">                while (*p == &apos;*&apos;) p++;  //skip continuous &apos;*&apos;</span><br><span class="line">                if (*p == &apos;\0&apos;) return true;</span><br><span class="line">                str = s - 1;</span><br><span class="line">                ptr = p - 1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                if (*str != *ptr) &#123;</span><br><span class="line">                    // 如果前面没有&apos;*&apos;，则匹配不成功</span><br><span class="line">                    if (!star) return false;</span><br><span class="line">                    s++;</span><br><span class="line">                    str = s - 1;</span><br><span class="line">                    ptr = p - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (*ptr == &apos;*&apos;) ptr++;</span><br><span class="line">        return (*ptr == &apos;\0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-8编写一个函数来查找字符串数组中最长的公共前缀字符串。"><a href="#3-8编写一个函数来查找字符串数组中最长的公共前缀字符串。" class="headerlink" title="3.8编写一个函数来查找字符串数组中最长的公共前缀字符串。"></a>3.8编写一个函数来查找字符串数组中最长的公共前缀字符串。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Common Prefix</span><br><span class="line">// 纵向扫描，从位置0开始，对每一个位置比较所有字符串，直到遇到一个不匹配</span><br><span class="line">// 时间复杂度O(n1+n2+...)</span><br><span class="line">// @author 周倩 (http://weibo.com/zhouditty)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) &#123;</span><br><span class="line">        if (strs.empty()) return &quot;&quot;;</span><br><span class="line">        for (int idx = 0; idx &lt; strs[0].size(); ++idx) &#123; // 纵向扫描</span><br><span class="line">            for (int i = 1; i &lt; strs.size(); ++i) &#123;</span><br><span class="line">                if (strs[i][idx] != strs[0][idx]) return strs[0].substr(0,idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Common Prefix</span><br><span class="line">// 横向扫描，每个字符串与第0个字符串，从左到右比较，直到遇到一个不匹配，</span><br><span class="line">// 然后继续下一个字符串</span><br><span class="line">// 时间复杂度O(n1+n2+...)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) &#123;</span><br><span class="line">        if (strs.empty()) return &quot;&quot;;</span><br><span class="line">        int right_most = strs[0].size() - 1;</span><br><span class="line">        for (size_t i = 1; i &lt; strs.size(); i++)</span><br><span class="line">            for (int j = 0; j &lt;= right_most; j++)</span><br><span class="line">                if (strs[i][j] != strs[0][j])  // 不会越界，请参考string::[]的文档</span><br><span class="line">                    right_most = j - 1;</span><br><span class="line"></span><br><span class="line">        return strs[0].substr(0, right_most + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-9验证给定字符串是否为数字。一些例子：“0”-gt-true；“0-1”-gt-true；“abc”-gt-false；“1a”-gt-false；“2e10”-gt-true。-注意：它的目的是使问题陈述含糊不清。在实现一个需求之前，您应该先收集所有的需求。"><a href="#3-9验证给定字符串是否为数字。一些例子：“0”-gt-true；“0-1”-gt-true；“abc”-gt-false；“1a”-gt-false；“2e10”-gt-true。-注意：它的目的是使问题陈述含糊不清。在实现一个需求之前，您应该先收集所有的需求。" class="headerlink" title="3.9验证给定字符串是否为数字。一些例子：“0”=&gt;true；“0.1”=&gt;true；“abc”=&gt;false；“1a”=&gt;false；“2e10”=&gt;true。 注意：它的目的是使问题陈述含糊不清。在实现一个需求之前，您应该先收集所有的需求。"></a>3.9验证给定字符串是否为数字。一些例子：“0”=&gt;true；“0.1”=&gt;true；“abc”=&gt;false；“1a”=&gt;false；“2e10”=&gt;true。 注意：它的目的是使问题陈述含糊不清。在实现一个需求之前，您应该先收集所有的需求。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Valid Number</span><br><span class="line">// @author 龚陆安 (http://weibo.com/luangong)</span><br><span class="line">// finite automata，时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(const string&amp; s) &#123;</span><br><span class="line">        enum InputType &#123;</span><br><span class="line">            INVALID,    // 0</span><br><span class="line">            SPACE,      // 1</span><br><span class="line">            SIGN,       // 2</span><br><span class="line">            DIGIT,      // 3</span><br><span class="line">            DOT,        // 4</span><br><span class="line">            EXPONENT,   // 5</span><br><span class="line">            NUM_INPUTS  // 6</span><br><span class="line">        &#125;;</span><br><span class="line">        const int transitionTable[][NUM_INPUTS] = &#123;</span><br><span class="line">                -1, 0, 3, 1, 2, -1,      // next states for state 0</span><br><span class="line">                -1, 8, -1, 1, 4, 5,      // next states for state 1</span><br><span class="line">                -1, -1, -1, 4, -1, -1,   // next states for state 2</span><br><span class="line">                -1, -1, -1, 1, 2, -1,    // next states for state 3</span><br><span class="line">                -1, 8, -1, 4, -1, 5,     // next states for state 4</span><br><span class="line">                -1, -1, 6, 7, -1, -1,    // next states for state 5</span><br><span class="line">                -1, -1, -1, 7, -1, -1,   // next states for state 6</span><br><span class="line">                -1, 8, -1, 7, -1, -1,    // next states for state 7</span><br><span class="line">                -1, 8, -1, -1, -1, -1,   // next states for state 8</span><br><span class="line">                &#125;;</span><br><span class="line">        int state = 0;</span><br><span class="line">        for (auto ch : s) &#123;</span><br><span class="line">            InputType inputType = INVALID;</span><br><span class="line">            if (isspace(ch))</span><br><span class="line">                inputType = SPACE;</span><br><span class="line">            else if (ch == &apos;+&apos; || ch == &apos;-&apos;)</span><br><span class="line">                inputType = SIGN;</span><br><span class="line">            else if (isdigit(ch))</span><br><span class="line">                inputType = DIGIT;</span><br><span class="line">            else if (ch == &apos;.&apos;)</span><br><span class="line">                inputType = DOT;</span><br><span class="line">            else if (ch == &apos;e&apos; || ch == &apos;E&apos;)</span><br><span class="line">                inputType = EXPONENT;</span><br><span class="line">            // Get next state from current state and input symbol</span><br><span class="line">            state = transitionTable[state][inputType];</span><br><span class="line">            // Invalid input</span><br><span class="line">            if (state == -1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // If the current state belongs to one of the accepting (final) states,</span><br><span class="line">        // then the number is valid</span><br><span class="line">        return state == 1 || state == 4 || state == 7 || state == 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Valid Number</span><br><span class="line">// @author 连城 (http://weibo.com/lianchengzju)</span><br><span class="line">// 偷懒，直接用 strtod()，时间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber (const string&amp; s) &#123;</span><br><span class="line">        return isNumber(s.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool isNumber (char const* s) &#123;</span><br><span class="line">        char* endptr;</span><br><span class="line">        strtod (s, &amp;endptr);</span><br><span class="line">        if (endptr == s) return false;</span><br><span class="line">        for (; *endptr; ++endptr)</span><br><span class="line">            if (!isspace (*endptr)) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-10给定一个整数，将其转换为一个罗马数字。输入保证在1到3999之间。"><a href="#3-10给定一个整数，将其转换为一个罗马数字。输入保证在1到3999之间。" class="headerlink" title="3.10给定一个整数，将其转换为一个罗马数字。输入保证在1到3999之间。"></a>3.10给定一个整数，将其转换为一个罗马数字。输入保证在1到3999之间。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Integer to Roman</span><br><span class="line">// 时间复杂度O(num)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string intToRoman(int num) &#123;</span><br><span class="line">        const int radix[] = &#123;1000, 900, 500, 400, 100, 90,</span><br><span class="line">                50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">        const string symbol[] = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;,</span><br><span class="line">                &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line">        string roman;</span><br><span class="line">        for (size_t i = 0; num &gt; 0; ++i) &#123;</span><br><span class="line">            int count = num / radix[i];</span><br><span class="line">            num %= radix[i];</span><br><span class="line">            for (; count &gt; 0; --count) roman += symbol[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-11给定一个罗马数字，将其转换为整数。输入保证在1到3999之间。"><a href="#3-11给定一个罗马数字，将其转换为整数。输入保证在1到3999之间。" class="headerlink" title="3.11给定一个罗马数字，将其转换为整数。输入保证在1到3999之间。"></a>3.11给定一个罗马数字，将其转换为整数。输入保证在1到3999之间。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Roman to Integer</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    inline int map(const char c) &#123;</span><br><span class="line">        switch (c) &#123;</span><br><span class="line">        case &apos;I&apos;: return 1;</span><br><span class="line">        case &apos;V&apos;: return 5;</span><br><span class="line">        case &apos;X&apos;: return 10;</span><br><span class="line">        case &apos;L&apos;: return 50;</span><br><span class="line">        case &apos;C&apos;: return 100;</span><br><span class="line">        case &apos;D&apos;: return 500;</span><br><span class="line">        case &apos;M&apos;: return 1000;</span><br><span class="line">        default: return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int romanToInt(const string&amp; s) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (size_t i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; map(s[i]) &gt; map(s[i - 1])) &#123;</span><br><span class="line">                result += (map(s[i]) - 2 * map(s[i - 1]));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result += map(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-12计数和表示序列是整数的序列，开头如下：1，11，21，1211，111221，…。1被读出为“one-1”或11。11被读出为“two-1s”或21。21被读出为“one-2”，然后“one-1”或1211。给定一个整数n，生成第n个顺序。注意：整数序列将表示为字符串。"><a href="#3-12计数和表示序列是整数的序列，开头如下：1，11，21，1211，111221，…。1被读出为“one-1”或11。11被读出为“two-1s”或21。21被读出为“one-2”，然后“one-1”或1211。给定一个整数n，生成第n个顺序。注意：整数序列将表示为字符串。" class="headerlink" title="3.12计数和表示序列是整数的序列，开头如下：1，11，21，1211，111221，…。1被读出为“one 1”或11。11被读出为“two 1s”或21。21被读出为“one 2”，然后“one 1”或1211。给定一个整数n，生成第n个顺序。注意：整数序列将表示为字符串。"></a>3.12计数和表示序列是整数的序列，开头如下：1，11，21，1211，111221，…。1被读出为“one 1”或11。11被读出为“two 1s”或21。21被读出为“one 2”，然后“one 1”或1211。给定一个整数n，生成第n个顺序。注意：整数序列将表示为字符串。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Count and Say</span><br><span class="line">// @author 连城 (http://weibo.com/lianchengzju)</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string s(&quot;1&quot;);</span><br><span class="line">        while (--n)</span><br><span class="line">            s = getNext(s);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    string getNext(const string &amp;s) &#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        for (auto i = s.begin(); i != s.end(); ) &#123;</span><br><span class="line">            auto j = find_if(i, s.end(), bind1st(not_equal_to&lt;char&gt;(), *i));</span><br><span class="line">            ss &lt;&lt; distance(i, j) &lt;&lt; *i;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-13给定一个字符串数组，返回所有字符串组。注意：所有输入都是小写的。"><a href="#3-13给定一个字符串数组，返回所有字符串组。注意：所有输入都是小写的。" class="headerlink" title="3.13给定一个字符串数组，返回所有字符串组。注意：所有输入都是小写的。"></a>3.13给定一个字符串数组，返回所有字符串组。注意：所有输入都是小写的。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Anagrams</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; anagrams(vector&lt;string&gt; &amp;strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt; &gt; group;</span><br><span class="line">        for (const auto &amp;s : strs) &#123;</span><br><span class="line">            string key = s;</span><br><span class="line">            sort(key.begin(), key.end());</span><br><span class="line">            group[key].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        for (auto it = group.cbegin(); it != group.cend(); it++) &#123;</span><br><span class="line">            if (it-&gt;second.size() &gt; 1)</span><br><span class="line">                result.insert(result.end(), it-&gt;second.begin(), it-&gt;second.end());</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-14给定文件-Unix样式-的绝对路径，简化它。例如，path-“-home-”-gt-“-home”；path-“-a-b-c-”-gt-“-c”。情况：·您考虑过path-“-”的情况吗？在这种情况下，您应该返回“-”。·另一种情况是路径可能包含多个斜杠‘-’，例如“-home-foo-”。在这种情况下，您应该忽略多余的斜杠并返回“-home-foo”。"><a href="#3-14给定文件-Unix样式-的绝对路径，简化它。例如，path-“-home-”-gt-“-home”；path-“-a-b-c-”-gt-“-c”。情况：·您考虑过path-“-”的情况吗？在这种情况下，您应该返回“-”。·另一种情况是路径可能包含多个斜杠‘-’，例如“-home-foo-”。在这种情况下，您应该忽略多余的斜杠并返回“-home-foo”。" class="headerlink" title="3.14给定文件(Unix样式)的绝对路径，简化它。例如，path=“/home/”=&gt;“/home”；path=“/a/.b/./c/”=&gt;“/c”。情况：·您考虑过path=“/../”的情况吗？在这种情况下，您应该返回“/”。·另一种情况是路径可能包含多个斜杠‘/’，例如“/home/foo/”。在这种情况下，您应该忽略多余的斜杠并返回“/home/foo”。"></a>3.14给定文件(Unix样式)的绝对路径，简化它。例如，path=“/home/”=&gt;“/home”；path=“/a/.b/./c/”=&gt;“/c”。情况：·您考虑过path=“/../”的情况吗？在这种情况下，您应该返回“/”。·另一种情况是路径可能包含多个斜杠‘/’，例如“/home/foo/”。在这种情况下，您应该忽略多余的斜杠并返回“/home/foo”。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Simplify Path</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string simplifyPath(const string&amp; path) &#123;</span><br><span class="line">        vector&lt;string&gt; dirs; // 当做栈</span><br><span class="line">        for (auto i = path.begin(); i != path.end();) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            auto j = find(i, path.end(), &apos;/&apos;);</span><br><span class="line">            auto dir = string(i, j);</span><br><span class="line">            if (!dir.empty() &amp;&amp; dir != &quot;.&quot;) &#123;// 当有连续 &apos;///&apos;时，dir 为空</span><br><span class="line">                if (dir == &quot;..&quot;) &#123;</span><br><span class="line">                    if (!dirs.empty())</span><br><span class="line">                        dirs.pop_back();</span><br><span class="line">                &#125; else</span><br><span class="line">                    dirs.push_back(dir);</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        stringstream out;</span><br><span class="line">        if (dirs.empty()) &#123;</span><br><span class="line">            out &lt;&lt; &quot;/&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (auto dir : dirs)</span><br><span class="line">                out &lt;&lt; &apos;/&apos; &lt;&lt; dir;</span><br><span class="line">        &#125;</span><br><span class="line">        return out.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-15如果字符串s由大小写字母和空格字符’-‘组成，则返回字符串中最后一个单词的长度。如果最后一个单词不存在，则返回0。注意：单词被定义为仅由非空格字符组成的字符序列。例如，给定s-“hello-world”，返回5。"><a href="#3-15如果字符串s由大小写字母和空格字符’-‘组成，则返回字符串中最后一个单词的长度。如果最后一个单词不存在，则返回0。注意：单词被定义为仅由非空格字符组成的字符序列。例如，给定s-“hello-world”，返回5。" class="headerlink" title="3.15如果字符串s由大小写字母和空格字符’ ‘组成，则返回字符串中最后一个单词的长度。如果最后一个单词不存在，则返回0。注意：单词被定义为仅由非空格字符组成的字符序列。例如，给定s=“hello world”，返回5。"></a>3.15如果字符串s由大小写字母和空格字符’ ‘组成，则返回字符串中最后一个单词的长度。如果最后一个单词不存在，则返回0。注意：单词被定义为仅由非空格字符组成的字符序列。例如，给定s=“hello world”，返回5。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 偷懒，用 STL</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(const string&amp; s) &#123;</span><br><span class="line">        auto first = find_if(s.rbegin(), s.rend(), ::isalpha);</span><br><span class="line">        auto last = find_if_not(first, s.rend(), ::isalpha);</span><br><span class="line">        return distance(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Length of Last Word</span><br><span class="line">// 顺序扫描，记录每个 word 的长度</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(const string&amp; s) &#123;</span><br><span class="line">        return lengthOfLastWord(s.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int lengthOfLastWord(const char *s) &#123;</span><br><span class="line">        int len = 0;</span><br><span class="line">        while (*s) &#123;</span><br><span class="line">            if (*s++ != &apos; &apos;)</span><br><span class="line">                ++len;</span><br><span class="line">            else if (*s &amp;&amp; *s != &apos; &apos;)</span><br><span class="line">                len = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-1栈"><a href="#4-1栈" class="headerlink" title="4.1栈"></a>4.1栈</h3><h4 id="4-1-1给定一个只包含字符’-‘-’-’-’-‘-’-’-’-‘和’-’的字符串，确定输入字符串是否有效。括号必须按照正确的顺序结束，”-”和”-”都是有效的，但是”-”和”-”不是。"><a href="#4-1-1给定一个只包含字符’-‘-’-’-’-‘-’-’-’-‘和’-’的字符串，确定输入字符串是否有效。括号必须按照正确的顺序结束，”-”和”-”都是有效的，但是”-”和”-”不是。" class="headerlink" title="4.1.1给定一个只包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’的字符串，确定输入字符串是否有效。括号必须按照正确的顺序结束，”()”和”()[]”都是有效的，但是”(]”和”([)]”不是。"></a>4.1.1给定一个只包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’的字符串，确定输入字符串是否有效。括号必须按照正确的顺序结束，”()”和”()[]”都是有效的，但是”(]”和”([)]”不是。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Valid Parentheses</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid (string const&amp; s) &#123;</span><br><span class="line">        string left = &quot;([&#123;&quot;;</span><br><span class="line">        string right = &quot;)]&#125;&quot;;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        for (auto c : s) &#123;</span><br><span class="line">            if (left.find(c) != string::npos) &#123;</span><br><span class="line">                stk.push (c);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (stk.empty () || stk.top () != left[right.find (c)])</span><br><span class="line">                    return false;</span><br><span class="line">                else</span><br><span class="line">                    stk.pop ();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2给定一个只包含字符‘-’和‘-’的字符串，查找最长的有效-格式良好-括号的长度。对于“-”，最长的有效括号子字符串是“-”，它的长度-2。另一个例子是“-”，其中最长的有效括号子字符串是“-”，它的长度-4。"><a href="#4-1-2给定一个只包含字符‘-’和‘-’的字符串，查找最长的有效-格式良好-括号的长度。对于“-”，最长的有效括号子字符串是“-”，它的长度-2。另一个例子是“-”，其中最长的有效括号子字符串是“-”，它的长度-4。" class="headerlink" title="4.1.2给定一个只包含字符‘(’和‘)’的字符串，查找最长的有效(格式良好)括号的长度。对于“(()”，最长的有效括号子字符串是“()”，它的长度=2。另一个例子是“)()())”，其中最长的有效括号子字符串是“()()”，它的长度=4。"></a>4.1.2给定一个只包含字符‘(’和‘)’的字符串，查找最长的有效(格式良好)括号的长度。对于“(()”，最长的有效括号子字符串是“()”，它的长度=2。另一个例子是“)()())”，其中最长的有效括号子字符串是“()()”，它的长度=4。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Valid Parenthese</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">// @author 一只杰森(http://weibo.com/wjson)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(const string&amp; s) &#123;</span><br><span class="line">        vector&lt;int&gt; f(s.size(), 0);</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = s.size() - 2; i &gt;= 0; --i) &#123;</span><br><span class="line">            int match = i + f[i + 1] + 1;</span><br><span class="line">            // case: &quot;((...))&quot;</span><br><span class="line">            if (s[i] == &apos;(&apos; &amp;&amp; match &lt; s.size() &amp;&amp; s[match] == &apos;)&apos;) &#123;</span><br><span class="line">                f[i] = f[i + 1] + 2;</span><br><span class="line">                // if a valid sequence exist afterwards &quot;((...))()&quot;</span><br><span class="line">                if (match + 1 &lt; s.size()) f[i] += f[match + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3给定n个非负整数表示直方图的条高，其中每条的宽度为1，则在直方图中找出最大矩形的面积。"><a href="#4-1-3给定n个非负整数表示直方图的条高，其中每条的宽度为1，则在直方图中找出最大矩形的面积。" class="headerlink" title="4.1.3给定n个非负整数表示直方图的条高，其中每条的宽度为1，则在直方图中找出最大矩形的面积。"></a>4.1.3给定n个非负整数表示直方图的条高，其中每条的宽度为1，则在直方图中找出最大矩形的面积。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Largest Rectangle in Histogram</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        height.push_back(0);</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i = 0; i &lt; height.size(); ) &#123;</span><br><span class="line">            if (s.empty() || height[i] &gt; height[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            else &#123;</span><br><span class="line">                int tmp = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                result = max(result,</span><br><span class="line">                height[tmp] * (s.empty() ? i : i - s.top() - 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-4用反波兰法计算算术表达式的值。有效运算符是-，-，，-。每个操作数可能是一个整数或另一个表达式。例如：-“2”-”1”-”-”-”3”-”“-gt-2-1-3-gt-9；-“4”-”13”-”5”-”-“-”-”-gt-4-13-5-gt-6"><a href="#4-1-4用反波兰法计算算术表达式的值。有效运算符是-，-，，-。每个操作数可能是一个整数或另一个表达式。例如：-“2”-”1”-”-”-”3”-”“-gt-2-1-3-gt-9；-“4”-”13”-”5”-”-“-”-”-gt-4-13-5-gt-6" class="headerlink" title="4.1.4用反波兰法计算算术表达式的值。有效运算符是+，-，，/。每个操作数可能是一个整数或另一个表达式。例如：[“2”,”1”,”+”,”3”,”“)-&gt;((2+1)*3)-&gt;9；[“4”,”13”,”5”,”/“,”+”]-&gt;(4+(13/5))-&gt;6"></a>4.1.4用反波兰法计算算术表达式的值。有效运算符是+，-，<em>，/。每个操作数可能是一个整数或另一个表达式。例如：[“2”,”1”,”+”,”3”,”</em>“)-&gt;((2+1)*3)-&gt;9；[“4”,”13”,”5”,”/“,”+”]-&gt;(4+(13/5))-&gt;6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Evaluate Reverse Polish Notation</span><br><span class="line">//递归，时间复杂度O(n)，空间复杂度O(logn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt; &amp;tokens) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        auto token = tokens.back(); tokens.pop_back();</span><br><span class="line">        if (is_operator(token)) &#123;</span><br><span class="line">            y = evalRPN(tokens);</span><br><span class="line">            x = evalRPN(tokens);</span><br><span class="line">            if (token[0] == &apos;+&apos;) x += y;</span><br><span class="line">            else if (token[0] == &apos;-&apos;) x -= y;</span><br><span class="line">            else if (token[0] == &apos;*&apos;) x *= y;</span><br><span class="line">            else x /= y;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size_t i;</span><br><span class="line">            x = stoi(token, &amp;i);</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool is_operator(const string &amp;op) &#123;</span><br><span class="line">        return op.size() == 1 &amp;&amp; string(&quot;+-*/&quot;).find(op) != string::npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7查找"><a href="#7查找" class="headerlink" title="7查找"></a>7查找</h3><h4 id="7-1给定一个排序的整数数组，找到给定目标值的起始和结束位置。算法的运行时复杂度必须是O-logn-的顺序。如果在数组中找不到目标，返回-1，-1-。例如，给定-5，7，7，8，8，10-和目标值8，返回-3，4-。–34"><a href="#7-1给定一个排序的整数数组，找到给定目标值的起始和结束位置。算法的运行时复杂度必须是O-logn-的顺序。如果在数组中找不到目标，返回-1，-1-。例如，给定-5，7，7，8，8，10-和目标值8，返回-3，4-。–34" class="headerlink" title="7.1给定一个排序的整数数组，找到给定目标值的起始和结束位置。算法的运行时复杂度必须是O(logn)的顺序。如果在数组中找不到目标，返回[-1，-1]。例如，给定[5，7，7，8，8，10]和目标值8，返回[3，4]。–34"></a>7.1给定一个排序的整数数组，找到给定目标值的起始和结束位置。算法的运行时复杂度必须是O(logn)的顺序。如果在数组中找不到目标，返回[-1，-1]。例如，给定[5，7，7，8，8，10]和目标值8，返回[3，4]。–34</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//二分查找</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int idx = search(nums, 0, nums.size() - 1, target);</span><br><span class="line">        if (idx == -1) return &#123;-1, -1&#125;;</span><br><span class="line">        int left = idx, right = idx;</span><br><span class="line">        while (left &gt; 0 &amp;&amp; nums[left - 1] == nums[idx]) --left;</span><br><span class="line">        while (right &lt; nums.size() - 1 &amp;&amp; nums[right + 1] == nums[idx]) ++right;</span><br><span class="line">        return &#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int left, int right, int target) &#123;</span><br><span class="line">        if (left &gt; right) return -1;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target) return mid;</span><br><span class="line">        else if (nums[mid] &lt; target) return search(nums, mid + 1, right, target);</span><br><span class="line">        else return search(nums, left, mid - 1, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//两次二分查找</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; res(2, -1);</span><br><span class="line">        int left = 0, right = nums.size() - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] &lt; target) left = mid + 1;</span><br><span class="line">            else right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[right] != target) return res;</span><br><span class="line">        res[0] = right;</span><br><span class="line">        right = nums.size();</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] &lt;= target) left = mid + 1;</span><br><span class="line">            else right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[1] = left - 1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-2给定一个排序数组和一个目标值，如果找到目标，返回索引。如果没有，则返回索引，如果它是按顺序插入的话。您可以假设数组中没有重复项。-1-3-5-6-5-→-2；-1-3-5-6-2-→-1；-1-3-5-6-7-→-4；-1-3-5-6-0-→-0"><a href="#7-2给定一个排序数组和一个目标值，如果找到目标，返回索引。如果没有，则返回索引，如果它是按顺序插入的话。您可以假设数组中没有重复项。-1-3-5-6-5-→-2；-1-3-5-6-2-→-1；-1-3-5-6-7-→-4；-1-3-5-6-0-→-0" class="headerlink" title="7.2给定一个排序数组和一个目标值，如果找到目标，返回索引。如果没有，则返回索引，如果它是按顺序插入的话。您可以假设数组中没有重复项。[1,3,5,6], 5 → 2；[1,3,5,6], 2 → 1；[1,3,5,6], 7 → 4；[1,3,5,6], 0 → 0"></a>7.2给定一个排序数组和一个目标值，如果找到目标，返回索引。如果没有，则返回索引，如果它是按顺序插入的话。您可以假设数组中没有重复项。[1,3,5,6], 5 → 2；[1,3,5,6], 2 → 1；[1,3,5,6], 7 → 4；[1,3,5,6], 0 → 0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Search Insert Position</span><br><span class="line">// 重新实现lower_bound</span><br><span class="line">// 时间复杂度 O(logn)，空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        return distance(nums.begin(), lower_bound(nums.begin(), nums.end(), target));</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename ForwardIterator, typename T&gt;</span><br><span class="line">    ForwardIterator lower_bound (ForwardIterator first,ForwardIterator last, T value) &#123;</span><br><span class="line">        while (first != last) &#123;</span><br><span class="line">            auto mid = next(first, distance(first, last) / 2);</span><br><span class="line">            if (value &gt; *mid) first = ++mid;</span><br><span class="line">            else last = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-3编写一个在m×n矩阵中搜索值的有效算法。该矩阵具有以下属性：-每行中的整数从左到右排序。·每一行的第一个整数大于上一行的最后一个整数。-1-3-5-7-10-11-16-20-23-30-34-50-，给定目标值-3，返回true。"><a href="#7-3编写一个在m×n矩阵中搜索值的有效算法。该矩阵具有以下属性：-每行中的整数从左到右排序。·每一行的第一个整数大于上一行的最后一个整数。-1-3-5-7-10-11-16-20-23-30-34-50-，给定目标值-3，返回true。" class="headerlink" title="7.3编写一个在m×n矩阵中搜索值的有效算法。该矩阵具有以下属性：.每行中的整数从左到右排序。·每一行的第一个整数大于上一行的最后一个整数。[[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 50]]，给定目标值=3，返回true。"></a>7.3编写一个在m×n矩阵中搜索值的有效算法。该矩阵具有以下属性：.每行中的整数从左到右排序。·每一行的第一个整数大于上一行的最后一个整数。[[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 50]]，给定目标值=3，返回true。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Search a 2D Matrix</span><br><span class="line">// 时间复杂度 O(logn)，空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if (matrix.empty()) return false;</span><br><span class="line">        const size_t m = matrix.size();</span><br><span class="line">        const size_t n = matrix.front().size();</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = m * n;</span><br><span class="line">        while (first &lt; last) &#123;</span><br><span class="line">            int mid = first + (last - first) / 2;</span><br><span class="line">            int value = matrix[mid / n][mid % n];</span><br><span class="line">            if (value == target)</span><br><span class="line">                return true;</span><br><span class="line">            else if (value &lt; target)</span><br><span class="line">                first = mid + 1;</span><br><span class="line">            else</span><br><span class="line">                last = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-暴力枚举法"><a href="#8-暴力枚举法" class="headerlink" title="8.暴力枚举法"></a>8.暴力枚举法</h3><h4 id="8-1给定一组不同的整数S，返回所有可能的子集。注：子集中的元素必须是非降序的。·解集不能包含重复的子集。例如，如果S-1，2，3-，解决方案是：-3-1-2-1-2-3-1-3-2-3-1-2-。"><a href="#8-1给定一组不同的整数S，返回所有可能的子集。注：子集中的元素必须是非降序的。·解集不能包含重复的子集。例如，如果S-1，2，3-，解决方案是：-3-1-2-1-2-3-1-3-2-3-1-2-。" class="headerlink" title="8.1给定一组不同的整数S，返回所有可能的子集。注：子集中的元素必须是非降序的。·解集不能包含重复的子集。例如，如果S=[1，2，3]，解决方案是：[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]。"></a>8.1给定一组不同的整数S，返回所有可能的子集。注：子集中的元素必须是非降序的。·解集不能包含重复的子集。例如，如果S=[1，2，3]，解决方案是：[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">增量构造法</span><br><span class="line">// LeetCode, Subsets</span><br><span class="line">// 迭代版，时间复杂度O(2^n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123;</span><br><span class="line">        sort(S.begin(), S.end()); // 输出要求有序</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result(1);</span><br><span class="line">        for (auto elem : S) &#123;</span><br><span class="line">            result.reserve(result.size() * 2);</span><br><span class="line">            auto half = result.begin() + result.size();</span><br><span class="line">            copy(result.begin(), half, back_inserter(result));</span><br><span class="line">            for_each(half, result.end(), [&amp;elem](decltype(result[0]) &amp;e)&#123;</span><br><span class="line">                e.push_back(elem);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-2给定可能包含重复项的整数集合，返回所有可能的子集合。注意：子集中的元素必须是非降序的。解决方案集不能包含重复子集。例如，如果S-1，2，2-，解决方案是：-2-1-1-2-2-2-2-1-2-。"><a href="#8-2给定可能包含重复项的整数集合，返回所有可能的子集合。注意：子集中的元素必须是非降序的。解决方案集不能包含重复子集。例如，如果S-1，2，2-，解决方案是：-2-1-1-2-2-2-2-1-2-。" class="headerlink" title="8.2给定可能包含重复项的整数集合，返回所有可能的子集合。注意：子集中的元素必须是非降序的。解决方案集不能包含重复子集。例如，如果S=[1，2，2]，解决方案是：[[2],[1],[1,2,2],[2,2],[1,2],[]]。"></a>8.2给定可能包含重复项的整数集合，返回所有可能的子集合。注意：子集中的元素必须是非降序的。解决方案集不能包含重复子集。例如，如果S=[1，2，2]，解决方案是：[[2],[1],[1,2,2],[2,2],[1,2],[]]。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-广度优先搜索"><a href="#9-广度优先搜索" class="headerlink" title="9.广度优先搜索"></a>9.广度优先搜索</h3><h4 id="9-1给定两个单词-开始和结束-和一个字典，找到从开始到结束的最短转换序列的长度，这样：·一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start-”hit”-end-”cog”-dict-“hot”-”dot”-”dog”-”lot”-”log”-，作为一个最短的转换是”hit”-gt-”hot”-gt-”dot”-gt-”dog”-gt-”cog”，返回它的长度5。注意：如果没有这样的转换序列，返回0。所有单词都有相同的长度。所有单词只包含小写字母字符。–127"><a href="#9-1给定两个单词-开始和结束-和一个字典，找到从开始到结束的最短转换序列的长度，这样：·一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start-”hit”-end-”cog”-dict-“hot”-”dot”-”dog”-”lot”-”log”-，作为一个最短的转换是”hit”-gt-”hot”-gt-”dot”-gt-”dog”-gt-”cog”，返回它的长度5。注意：如果没有这样的转换序列，返回0。所有单词都有相同的长度。所有单词只包含小写字母字符。–127" class="headerlink" title="9.1给定两个单词(开始和结束)和一个字典，找到从开始到结束的最短转换序列的长度，这样：·一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start=”hit” end=”cog” dict=[“hot”,”dot”,”dog”,”lot”,”log”]，作为一个最短的转换是”hit”-&gt;”hot”-&gt;”dot”-&gt;”dog”-&gt;”cog”，返回它的长度5。注意：如果没有这样的转换序列，返回0。所有单词都有相同的长度。所有单词只包含小写字母字符。–127"></a>9.1给定两个单词(开始和结束)和一个字典，找到从开始到结束的最短转换序列的长度，这样：·一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start=”hit” end=”cog” dict=[“hot”,”dot”,”dog”,”lot”,”log”]，作为一个最短的转换是”hit”-&gt;”hot”-&gt;”dot”-&gt;”dog”-&gt;”cog”，返回它的长度5。注意：如果没有这样的转换序列，返回0。所有单词都有相同的长度。所有单词只包含小写字母字符。–127</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//暴力搜索</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end());</span><br><span class="line">        unordered_map&lt;string, int&gt; m;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        m[beginWord] = 1;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            string word = q.front(); </span><br><span class="line">            q.pop();</span><br><span class="line">            for (int i = 0; i &lt; word.size(); ++i) &#123;</span><br><span class="line">                string newWord = word;</span><br><span class="line">                for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ++ch) &#123;</span><br><span class="line">                    newWord[i] = ch;</span><br><span class="line">                    if (dict.count(newWord) &amp;&amp; newWord == endWord) return m[word] + 1;</span><br><span class="line">                    if (dict.count(newWord) &amp;&amp; !m.count(newWord)) &#123;</span><br><span class="line">                        q.push(newWord);</span><br><span class="line">                        m[newWord] = m[word] + 1;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode, Word Ladder</span><br><span class="line">//单队列</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">struct state_t &#123;</span><br><span class="line">    string word;</span><br><span class="line">    int level;</span><br><span class="line">    state_t() &#123; word = &quot;&quot;; level = 0; &#125;</span><br><span class="line">    state_t(const string&amp; word, int level) &#123;</span><br><span class="line">        this-&gt;word = word;</span><br><span class="line">        this-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const state_t &amp;other) const &#123;</span><br><span class="line">        return this-&gt;word == other.word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">namespace std &#123;</span><br><span class="line">    template&lt;&gt; struct hash&lt;state_t&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        size_t operator()(const state_t&amp; s) const &#123;</span><br><span class="line">            return str_hash(s.word);</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        std::hash&lt;std::string&gt; str_hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ladderLength(const string&amp; start, const string &amp;end,</span><br><span class="line">    const unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        queue&lt;state_t&gt; q;</span><br><span class="line">        unordered_set&lt;state_t&gt; visited; // 判重</span><br><span class="line">        auto state_is_valid = [&amp;](const state_t&amp; s) &#123;</span><br><span class="line">            return dict.find(s.word) != dict.end() || s.word == end;</span><br><span class="line">        &#125;;</span><br><span class="line">        auto state_is_target = [&amp;](const state_t &amp;s) &#123;return s.word == end; &#125;;</span><br><span class="line">        auto state_extend = [&amp;](const state_t &amp;s) &#123;</span><br><span class="line">            unordered_set&lt;state_t&gt; result;</span><br><span class="line">            for (size_t i = 0; i &lt; s.word.size(); ++i) &#123;</span><br><span class="line">                state_t new_state(s.word, s.level + 1);</span><br><span class="line">                for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123;</span><br><span class="line">                    // 防止同字母替换</span><br><span class="line">                    if (c == new_state.word[i]) continue;</span><br><span class="line">                    swap(c, new_state.word[i]);</span><br><span class="line">                    if (state_is_valid(new_state) &amp;&amp;visited.find(new_state) == visited.end()) &#123;</span><br><span class="line">                        result.insert(new_state);</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(c, new_state.word[i]); // 恢复该单词</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;;</span><br><span class="line">        state_t start_state(start, 0);</span><br><span class="line">        q.push(start_state);</span><br><span class="line">        visited.insert(start_state);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            //千万不能用const auto&amp;，pop()会删除元素 </span><br><span class="line">            //引用就变成了悬空引用</span><br><span class="line">            const auto state = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if (state_is_target(state)) &#123;</span><br><span class="line">                return state.level + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            const auto&amp; new_states = state_extend(state);</span><br><span class="line">            for (const auto&amp; new_state : new_states) &#123;</span><br><span class="line">                q.push(new_state);</span><br><span class="line">                visited.insert(new_state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode, Word Ladder</span><br><span class="line">//双队列</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ladderLength(const string&amp; start, const string &amp;end,</span><br><span class="line">    const unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        queue&lt;string&gt; current, next; // 当前层，下一层</span><br><span class="line">        unordered_set&lt;string&gt; visited; // 判重</span><br><span class="line">        int level = -1; //层次</span><br><span class="line">        auto state_is_valid = [&amp;](const string&amp; s) &#123;</span><br><span class="line">            return dict.find(s) != dict.end() || s == end;</span><br><span class="line">        &#125;;</span><br><span class="line">        auto state_is_target = [&amp;](const string &amp;s) &#123;return s == end;&#125;;</span><br><span class="line">        auto state_extend = [&amp;](const string &amp;s) &#123;</span><br><span class="line">            unordered_set&lt;string&gt; result;</span><br><span class="line">            for (size_t i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">                string new_word(s);</span><br><span class="line">                for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123;</span><br><span class="line">                    // 防止同字母替换</span><br><span class="line">                    if (c == new_word[i]) continue;</span><br><span class="line">                    swap(c, new_word[i]);</span><br><span class="line">                    if (state_is_valid(new_word) &amp;&amp; visited.find(new_word) == visited.end()) &#123;</span><br><span class="line">                        result.insert(new_word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(c, new_word[i]); // 恢复该单词</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;;</span><br><span class="line">        current.push(start);</span><br><span class="line">        visited.insert(start);</span><br><span class="line">        while (!current.empty()) &#123;</span><br><span class="line">            ++level;</span><br><span class="line">            while (!current.empty()) &#123;</span><br><span class="line">                //千万不能用const auto&amp;，pop()会删除元素 </span><br><span class="line">                //引用就变成了悬空引用</span><br><span class="line">                const auto state = current.front();</span><br><span class="line">                current.pop();</span><br><span class="line">                if (state_is_target(state)) &#123;</span><br><span class="line">                    return level + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                const auto&amp; new_states = state_extend(state);</span><br><span class="line">                for (const auto&amp; new_state : new_states) &#123;</span><br><span class="line">                    next.push(new_state);</span><br><span class="line">                    visited.insert(new_state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(next, current);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-2给定两个单词-开始和结束-和一个字典，从开始到结束查找所有最短的转换序列，这样：一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start-“hit”-end-“cog”-dict-“hot”-”dot”-”dog”-”lot”-”log”-，返回-“hit”-”hot”-”dot”-”dog”-”cog”-“hit”-”hot”-”lot”-”log”-”cog”-。注：·所有单词的长度相同。·所有单词只包含小写字母字符"><a href="#9-2给定两个单词-开始和结束-和一个字典，从开始到结束查找所有最短的转换序列，这样：一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start-“hit”-end-“cog”-dict-“hot”-”dot”-”dog”-”lot”-”log”-，返回-“hit”-”hot”-”dot”-”dog”-”cog”-“hit”-”hot”-”lot”-”log”-”cog”-。注：·所有单词的长度相同。·所有单词只包含小写字母字符" class="headerlink" title="9.2给定两个单词(开始和结束)和一个字典，从开始到结束查找所有最短的转换序列，这样：一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start = “hit” end = “cog” dict = [“hot”,”dot”,”dog”,”lot”,”log”]，返回[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]。注：·所有单词的长度相同。·所有单词只包含小写字母字符"></a>9.2给定两个单词(开始和结束)和一个字典，从开始到结束查找所有最短的转换序列，这样：一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start = “hit” end = “cog” dict = [“hot”,”dot”,”dog”,”lot”,”log”]，返回[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]。注：·所有单词的长度相同。·所有单词只包含小写字母字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end());</span><br><span class="line">        vector&lt;string&gt; p&#123;beginWord&#125;;</span><br><span class="line">        queue&lt;vector&lt;string&gt;&gt; paths;</span><br><span class="line">        paths.push(p);</span><br><span class="line">        int level = 1, minLevel = INT_MAX;</span><br><span class="line">        unordered_set&lt;string&gt; words;</span><br><span class="line">        while (!paths.empty()) &#123;</span><br><span class="line">            auto t = paths.front(); paths.pop();</span><br><span class="line">            if (t.size() &gt; level) &#123;</span><br><span class="line">                for (string w : words) dict.erase(w);</span><br><span class="line">                words.clear();</span><br><span class="line">                level = t.size();</span><br><span class="line">                if (level &gt; minLevel) break;</span><br><span class="line">            &#125;</span><br><span class="line">            string last = t.back();</span><br><span class="line">            for (int i = 0; i &lt; last.size(); ++i) &#123;</span><br><span class="line">                string newLast = last;</span><br><span class="line">                for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ++ch) &#123;</span><br><span class="line">                    newLast[i] = ch;</span><br><span class="line">                    if (!dict.count(newLast)) continue;</span><br><span class="line">                    words.insert(newLast);</span><br><span class="line">                    vector&lt;string&gt; nextPath = t;</span><br><span class="line">                    nextPath.push_back(newLast);</span><br><span class="line">                    if (newLast == endWord) &#123;</span><br><span class="line">                        res.push_back(nextPath);</span><br><span class="line">                        minLevel = level;</span><br><span class="line">                    &#125; else paths.push(nextPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">//单队列</span><br><span class="line">//LeetCode, Word Ladder II</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">struct state_t &#123;</span><br><span class="line">    string word;</span><br><span class="line">    int level;</span><br><span class="line">    state_t() &#123; word = &quot;&quot;; level = 0; &#125;</span><br><span class="line">    state_t(const string&amp; word, int level) &#123;</span><br><span class="line">        this-&gt;word = word;</span><br><span class="line">        this-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const state_t &amp;other) const &#123;</span><br><span class="line">        return this-&gt;word == other.word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">namespace std &#123;</span><br><span class="line">    template&lt;&gt; struct hash&lt;state_t&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        size_t operator()(const state_t&amp; s) const &#123;</span><br><span class="line">            return str_hash(s.word);</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        std::hash&lt;std::string&gt; str_hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; findLadders(const string&amp; start,</span><br><span class="line">        const string&amp; end, const unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        queue&lt;state_t&gt; q;</span><br><span class="line">        unordered_set&lt;state_t&gt; visited; // 判重</span><br><span class="line">        unordered_map&lt;state_t, vector&lt;state_t&gt; &gt; father; // DAG</span><br><span class="line">        auto state_is_valid = [&amp;](const state_t&amp; s) &#123;</span><br><span class="line">            return dict.find(s.word) != dict.end() || s.word == end;</span><br><span class="line">        &#125;;</span><br><span class="line">        auto state_is_target = [&amp;](const state_t &amp;s) &#123;return s.word == end; &#125;;</span><br><span class="line">        auto state_extend = [&amp;](const state_t &amp;s) &#123;</span><br><span class="line">            unordered_set&lt;state_t&gt; result;</span><br><span class="line">            for (size_t i = 0; i &lt; s.word.size(); ++i) &#123;</span><br><span class="line">                state_t new_state(s.word, s.level + 1);</span><br><span class="line">                for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123;</span><br><span class="line">                    // 防止同字母替换</span><br><span class="line">                    if (c == new_state.word[i]) continue;</span><br><span class="line">                    swap(c, new_state.word[i]);</span><br><span class="line">                    if (state_is_valid(new_state)) &#123;</span><br><span class="line">                        auto visited_iter = visited.find(new_state);</span><br><span class="line">                        if (visited_iter != visited.end()) &#123;</span><br><span class="line">                            if (visited_iter-&gt;level &lt; new_state.level) &#123;</span><br><span class="line">                                // do nothing</span><br><span class="line">                            &#125; else if (visited_iter-&gt;level == new_state.level) &#123;</span><br><span class="line">                                result.insert(new_state);</span><br><span class="line">                            &#125; else &#123; // not possible</span><br><span class="line">                                throw std::logic_error(&quot;not possible to get here&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            result.insert(new_state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(c, new_state.word[i]); // 恢复该单词</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        state_t start_state(start, 0);</span><br><span class="line">        q.push(start_state);</span><br><span class="line">        visited.insert(start_state);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 千万不能用 const auto&amp;，pop() 会删除元素，</span><br><span class="line">            // 引用就变成了悬空引用</span><br><span class="line">            const auto state = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            // 如果当前路径长度已经超过当前最短路径长度，</span><br><span class="line">            // 可以中止对该路径的处理，因为我们要找的是最短路径</span><br><span class="line">            if (!result.empty() &amp;&amp; state.level + 1 &gt; result[0].size()) break;</span><br><span class="line">            if (state_is_target(state)) &#123;</span><br><span class="line">                vector&lt;string&gt; path;</span><br><span class="line">                gen_path(father, start_state, state, path, result);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 必须挪到下面，比如同一层A和B两个节点均指向了目标节点，</span><br><span class="line">            // 那么目标节点就会在q中出现两次，输出路径就会翻倍</span><br><span class="line">            // visited.insert(state);</span><br><span class="line">            // 扩展节点</span><br><span class="line">            const auto&amp; new_states = state_extend(state);</span><br><span class="line">            for (const auto&amp; new_state : new_states) &#123;</span><br><span class="line">                if (visited.find(new_state) == visited.end()) &#123;</span><br><span class="line">                    q.push(new_state);</span><br><span class="line">                &#125;</span><br><span class="line">                visited.insert(new_state);</span><br><span class="line">                father[new_state].push_back(state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void gen_path(unordered_map&lt;state_t, vector&lt;state_t&gt; &gt; &amp;father,</span><br><span class="line">        const state_t &amp;start, const state_t &amp;state, vector&lt;string&gt; &amp;path,</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; &amp;result) &#123;</span><br><span class="line">        path.push_back(state.word);</span><br><span class="line">        if (state == start) &#123;</span><br><span class="line">            if (!result.empty()) &#123;</span><br><span class="line">                if (path.size() &lt; result[0].size()) &#123;</span><br><span class="line">                    result.clear();</span><br><span class="line">                    result.push_back(path);</span><br><span class="line">                    reverse(result.back().begin(), result.back().end());</span><br><span class="line">                &#125; else if (path.size() == result[0].size()) &#123;</span><br><span class="line">                    result.push_back(path);</span><br><span class="line">                    reverse(result.back().begin(), result.back().end());</span><br><span class="line">                &#125; else &#123; // not possible</span><br><span class="line">                    throw std::logic_error(&quot;not possible to get here &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.push_back(path);</span><br><span class="line">                reverse(result.back().begin(), result.back().end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (const auto&amp; f : father[state]) &#123;</span><br><span class="line">                gen_path(father, start, f, path, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">//双队列</span><br><span class="line">//LeetCode, Word Ladder II</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; findLadders(const string&amp; start,</span><br><span class="line">            const string&amp; end, const unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        // 当前层，下一层，用unordered_set是为了去重，例如两个父节点指向</span><br><span class="line">        // 同一个子节点，如果用vector, 子节点就会在next里出现两次，其实此</span><br><span class="line">        // 时 father 已经记录了两个父节点，next里重复出现两次是没必要的</span><br><span class="line">        unordered_set&lt;string&gt; current, next;</span><br><span class="line">        unordered_set&lt;string&gt; visited; // 判重</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt; &gt; father; // DAG</span><br><span class="line">        int level = -1;  // 层次</span><br><span class="line">        auto state_is_valid = [&amp;](const string&amp; s) &#123;</span><br><span class="line">            return dict.find(s) != dict.end() || s == end;</span><br><span class="line">        &#125;;</span><br><span class="line">        auto state_is_target = [&amp;](const string &amp;s) &#123;return s == end;&#125;;</span><br><span class="line">        auto state_extend = [&amp;](const string &amp;s) &#123;</span><br><span class="line">            unordered_set&lt;string&gt; result;</span><br><span class="line">            for (size_t i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">                string new_word(s);</span><br><span class="line">                for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123;</span><br><span class="line">                    // 防止同字母替换</span><br><span class="line">                    if (c == new_word[i]) continue;</span><br><span class="line">                    swap(c, new_word[i]);</span><br><span class="line">                    if (state_is_valid(new_word) &amp;&amp;</span><br><span class="line">                            visited.find(new_word) == visited.end()) &#123;</span><br><span class="line">                        result.insert(new_word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(c, new_word[i]); // 恢复该单词</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line">        current.insert(start);</span><br><span class="line">        while (!current.empty()) &#123;</span><br><span class="line">            ++ level;</span><br><span class="line">            // 如果当前路径长度已经超过当前最短路径长度，可以中止对该路径的</span><br><span class="line">            // 处理，因为我们要找的是最短路径</span><br><span class="line">            if (!result.empty() &amp;&amp; level+1 &gt; result[0].size()) break;</span><br><span class="line">            // 1. 延迟加入visited, 这样才能允许两个父节点指向同一个子节点</span><br><span class="line">            // 2. 一股脑current 全部加入visited, 是防止本层前一个节点扩展</span><br><span class="line">            // 节点时，指向了本层后面尚未处理的节点，这条路径必然不是最短的</span><br><span class="line">            for (const auto&amp; state : current)</span><br><span class="line">                visited.insert(state);</span><br><span class="line">            for (const auto&amp; state : current) &#123;</span><br><span class="line">                if (state_is_target(state)) &#123;</span><br><span class="line">                    vector&lt;string&gt; path;</span><br><span class="line">                    gen_path(father, path, start, state, result);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                const auto new_states = state_extend(state);</span><br><span class="line">                for (const auto&amp; new_state : new_states) &#123;</span><br><span class="line">                    next.insert(new_state);</span><br><span class="line">                    father[new_state].push_back(state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            current.clear();</span><br><span class="line">            swap(current, next);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void gen_path(unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;father,</span><br><span class="line">            vector&lt;string&gt; &amp;path, const string &amp;start, const string &amp;word,</span><br><span class="line">            vector&lt;vector&lt;string&gt; &gt; &amp;result) &#123;</span><br><span class="line">        path.push_back(word);</span><br><span class="line">        if (word == start) &#123;</span><br><span class="line">            if (!result.empty()) &#123;</span><br><span class="line">                if (path.size() &lt; result[0].size()) &#123;</span><br><span class="line">                    result.clear();</span><br><span class="line">                    result.push_back(path);</span><br><span class="line">                &#125; else if(path.size() == result[0].size()) &#123;</span><br><span class="line">                    result.push_back(path);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // not possible</span><br><span class="line">                    throw std::logic_error(&quot;not possible to get here&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.push_back(path);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(result.back().begin(), result.back().end());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (const auto&amp; f : father[word]) &#123;</span><br><span class="line">                gen_path(father, path, start, f, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-3给定一个包含“x”和“o”的2D板，捕获所有被“x”包围的区域。一个区域是通过将“o”翻转到“x”来捕获的。例如，在运行您的功能之后，板子应该是："><a href="#9-3给定一个包含“x”和“o”的2D板，捕获所有被“x”包围的区域。一个区域是通过将“o”翻转到“x”来捕获的。例如，在运行您的功能之后，板子应该是：" class="headerlink" title="9.3给定一个包含“x”和“o”的2D板，捕获所有被“x”包围的区域。一个区域是通过将“o”翻转到“x”来捕获的。例如，在运行您的功能之后，板子应该是："></a>9.3给定一个包含“x”和“o”的2D板，捕获所有被“x”包围的区域。一个区域是通过将“o”翻转到“x”来捕获的。例如，在运行您的功能之后，板子应该是：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X X X X  </span><br><span class="line">X O O X  </span><br><span class="line">X X O X  </span><br><span class="line">X O X X  </span><br><span class="line">=&gt;  </span><br><span class="line">X X X X  </span><br><span class="line">X X X X  </span><br><span class="line">X X X X  </span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</span><br><span class="line">        for (int i = 0; i &lt; board.size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; board[i].size(); ++j) &#123;</span><br><span class="line">                if ((i == 0 || i == board.size() - 1 || j == 0 || j == board[i].size() - 1) &amp;&amp; board[i][j] == &apos;O&apos;)</span><br><span class="line">                    solveDFS(board, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; board.size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; board[i].size(); ++j) &#123;</span><br><span class="line">                if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;;</span><br><span class="line">                if (board[i][j] == &apos;$&apos;) board[i][j] = &apos;O&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void solveDFS(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j) &#123;</span><br><span class="line">        if (board[i][j] == &apos;O&apos;) &#123;</span><br><span class="line">            board[i][j] = &apos;$&apos;;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; board[i - 1][j] == &apos;O&apos;) </span><br><span class="line">                solveDFS(board, i - 1, j);</span><br><span class="line">            if (j &lt; board[i].size() - 1 &amp;&amp; board[i][j + 1] == &apos;O&apos;) </span><br><span class="line">                solveDFS(board, i, j + 1);</span><br><span class="line">            if (i &lt; board.size() - 1 &amp;&amp; board[i + 1][j] == &apos;O&apos;) </span><br><span class="line">                solveDFS(board, i + 1, j);</span><br><span class="line">            if (j &gt; 1 &amp;&amp; board[i][j - 1] == &apos;O&apos;) </span><br><span class="line">                solveDFS(board, i, j - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        if (board.empty() || board[0].empty()) return;</span><br><span class="line">        int m = board.size(), n = board[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) &#123;</span><br><span class="line">                    if (board[i][j] == &apos;O&apos;) dfs(board, i , j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;;</span><br><span class="line">                if (board[i][j] == &apos;$&apos;) board[i][j] = &apos;O&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int x, int y) &#123;</span><br><span class="line">        int m = board.size(), n = board[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dir&#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;&#125;;</span><br><span class="line">        board[x][y] = &apos;$&apos;;</span><br><span class="line">        for (int i = 0; i &lt; dir.size(); ++i) &#123;</span><br><span class="line">            int dx = x + dir[i][0], dy = y + dir[i][1];</span><br><span class="line">            if (dx &gt;= 0 &amp;&amp; dx &lt; m &amp;&amp; dy &gt; 0 &amp;&amp; dy &lt; n &amp;&amp; board[dx][dy] == &apos;O&apos;) &#123;</span><br><span class="line">                dfs(board, dx, dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Surrounded Regions</span><br><span class="line">// BFS，时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123;</span><br><span class="line">        if (board.empty()) return;</span><br><span class="line">        const int m = board.size();</span><br><span class="line">        const int n = board[0].size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            bfs(board, 0, i);</span><br><span class="line">            bfs(board, m - 1, i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt; m - 1; j++) &#123;</span><br><span class="line">            bfs(board, j, 0);</span><br><span class="line">            bfs(board, j, n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; m; i++)</span><br><span class="line">            for (int j = 0; j &lt; n; j++)</span><br><span class="line">                if (board[i][j] == &apos;O&apos;)</span><br><span class="line">                    board[i][j] = &apos;X&apos;;</span><br><span class="line">                else if (board[i][j] == &apos;+&apos;)</span><br><span class="line">                    board[i][j] = &apos;O&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void bfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j) &#123;</span><br><span class="line">        typedef pair&lt;int, int&gt; state_t;</span><br><span class="line">        queue&lt;state_t&gt; q;</span><br><span class="line">        const int m = board.size();</span><br><span class="line">        const int n = board[0].size();</span><br><span class="line">        auto state_is_valid = [&amp;](const state_t &amp;s) &#123;</span><br><span class="line">            const int x = s.first;</span><br><span class="line">            const int y = s.second;</span><br><span class="line">            if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] != &apos;O&apos;)</span><br><span class="line">                return false;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        auto state_extend = [&amp;](const state_t &amp;s) &#123;</span><br><span class="line">            vector&lt;state_t&gt; result;</span><br><span class="line">            const int x = s.first;</span><br><span class="line">            const int y = s.second;</span><br><span class="line">            // 上下左右</span><br><span class="line">            const state_t new_states[4] = &#123;&#123;x-1,y&#125;, &#123;x+1,y&#125;,</span><br><span class="line">                    &#123;x,y-1&#125;, &#123;x,y+1&#125;&#125;;</span><br><span class="line">            for (int k = 0; k &lt; 4;  ++k) &#123;</span><br><span class="line">                if (state_is_valid(new_states[k])) &#123;</span><br><span class="line">                    // 既有标记功能又有去重功能</span><br><span class="line">                    board[new_states[k].first][new_states[k].second] = &apos;+&apos;;</span><br><span class="line">                    result.push_back(new_states[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;;</span><br><span class="line">        state_t start = &#123; i, j &#125;;</span><br><span class="line">        if (state_is_valid(start)) &#123;</span><br><span class="line">            board[i][j] = &apos;+&apos;;</span><br><span class="line">            q.push(start);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            auto new_states = state_extend(cur);</span><br><span class="line">            for (auto s : new_states) q.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10深度优先搜索"><a href="#10深度优先搜索" class="headerlink" title="10深度优先搜索"></a>10深度优先搜索</h3><h4 id="10-1给定字符串s，分区s使得分区的每个子字符串都是回文。返回S的所有可能的回文分区。例如，给定s-“AAB”，返回-“aa”-”b”-，-“a”-”b”-。–131"><a href="#10-1给定字符串s，分区s使得分区的每个子字符串都是回文。返回S的所有可能的回文分区。例如，给定s-“AAB”，返回-“aa”-”b”-，-“a”-”b”-。–131" class="headerlink" title="10.1给定字符串s，分区s使得分区的每个子字符串都是回文。返回S的所有可能的回文分区。例如，给定s=“AAB”，返回[“aa”,”b”]，[“a”,”b”]。–131"></a>10.1给定字符串s，分区s使得分区的每个子字符串都是回文。返回S的所有可能的回文分区。例如，给定s=“AAB”，返回[“aa”,”b”]，[“a”,”b”]。–131</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        vector&lt;string&gt; out;</span><br><span class="line">        partitionDFS(s, 0, out, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void partitionDFS(string s, int start, vector&lt;string&gt; &amp;out, vector&lt;vector&lt;string&gt;&gt; &amp;res) &#123;</span><br><span class="line">        if (start == s.size()) &#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (isPalindrome(s, start, i)) &#123;</span><br><span class="line">                out.push_back(s.substr(start, i - start + 1));</span><br><span class="line">                partitionDFS(s, i + 1, out, res);</span><br><span class="line">                out.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isPalindrome(string s, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if (s[start] != s[end]) return false;</span><br><span class="line">            ++start;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-2机器人位于m×n网格的左上角-在下图中标记为“start”-。机器人只能在任何时间点向下或向右移动。机器人试图到达网格的右下角-在下图中标记为“Finish”-。有多少条可能的唯一路径？"><a href="#10-2机器人位于m×n网格的左上角-在下图中标记为“start”-。机器人只能在任何时间点向下或向右移动。机器人试图到达网格的右下角-在下图中标记为“Finish”-。有多少条可能的唯一路径？" class="headerlink" title="10.2机器人位于m×n网格的左上角(在下图中标记为“start”)。机器人只能在任何时间点向下或向右移动。机器人试图到达网格的右下角(在下图中标记为“Finish”)。有多少条可能的唯一路径？"></a>10.2机器人位于m×n网格的左上角(在下图中标记为“start”)。机器人只能在任何时间点向下或向右移动。机器人试图到达网格的右下角(在下图中标记为“Finish”)。有多少条可能的唯一路径？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Unique Paths</span><br><span class="line">// 深搜，小集合可以过，大集合超时</span><br><span class="line">// 时间复杂度 O(n^4)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if (m &lt; 1 || n &lt; 1) return 0; // 终止条件</span><br><span class="line">        if (m == 1 &amp;&amp; n == 1) return 1; //  收敛条件</span><br><span class="line">        return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Unique Paths</span><br><span class="line">// 动规，滚动数组</span><br><span class="line">// 时间复杂度 O(n^2)，空间复杂度 O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; f(n, 0);</span><br><span class="line">        f[0] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                // 左边的f[j]表示更新后的f[j]，与公式中的f[i][j]对应</span><br><span class="line">                // 右边的f[j]表示老的f[j]，与公式中的f[i-1][j]对应</span><br><span class="line">                f[j] = f[j] + f[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-3跟踪“唯一路径”：现在考虑是否在网格中添加了一些障碍。会有多少条唯一的路径？在网格中，一个障碍和空间分别标记为1和0。例如，在3×3网格的中间有一个障碍，如下图所示。唯一路径的总数为2。"><a href="#10-3跟踪“唯一路径”：现在考虑是否在网格中添加了一些障碍。会有多少条唯一的路径？在网格中，一个障碍和空间分别标记为1和0。例如，在3×3网格的中间有一个障碍，如下图所示。唯一路径的总数为2。" class="headerlink" title="10.3跟踪“唯一路径”：现在考虑是否在网格中添加了一些障碍。会有多少条唯一的路径？在网格中，一个障碍和空间分别标记为1和0。例如，在3×3网格的中间有一个障碍，如下图所示。唯一路径的总数为2。"></a>10.3跟踪“唯一路径”：现在考虑是否在网格中添加了一些障碍。会有多少条唯一的路径？在网格中，一个障碍和空间分别标记为1和0。例如，在3×3网格的中间有一个障碍，如下图所示。唯一路径的总数为2。</h4><pre><code>[
[0,0,0],
[0,1,0],
[0,0,0]
]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Unique Paths II</span><br><span class="line">// 动规，滚动数组</span><br><span class="line">// 时间复杂度 O(n^2)，空间复杂度 O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123;</span><br><span class="line">        const int m = obstacleGrid.size();</span><br><span class="line">        const int n = obstacleGrid[0].size();</span><br><span class="line">        if (obstacleGrid[0][0] || obstacleGrid[m-1][n-1]) return 0;</span><br><span class="line">        vector&lt;int&gt; f(n, 0);</span><br><span class="line">        f[0] = obstacleGrid[0][0] ? 0 : 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            f[0] = f[0] == 0 ? 0 : (obstacleGrid[i][0] ? 0 : 1);</span><br><span class="line">            for (int j = 1; j &lt; n; j++)</span><br><span class="line">                f[j] = obstacleGrid[i][j] ? 0 : (f[j] + f[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-4n皇后之谜是在n×n棋盘上放置n个皇后的问题，这样就不会有两个皇后互相攻击。给定一个整数n，返回n皇后谜题的所有不同的解。每个解都包含n皇后位置的一个不同的板配置，其中‘Q’和‘-’都分别表示一个皇后和一个空间。例如，对于4皇后之谜，有两种不同的解决方案："><a href="#10-4n皇后之谜是在n×n棋盘上放置n个皇后的问题，这样就不会有两个皇后互相攻击。给定一个整数n，返回n皇后谜题的所有不同的解。每个解都包含n皇后位置的一个不同的板配置，其中‘Q’和‘-’都分别表示一个皇后和一个空间。例如，对于4皇后之谜，有两种不同的解决方案：" class="headerlink" title="10.4n皇后之谜是在n×n棋盘上放置n个皇后的问题，这样就不会有两个皇后互相攻击。给定一个整数n，返回n皇后谜题的所有不同的解。每个解都包含n皇后位置的一个不同的板配置，其中‘Q’和‘.’都分别表示一个皇后和一个空间。例如，对于4皇后之谜，有两种不同的解决方案："></a>10.4n皇后之谜是在n×n棋盘上放置n个皇后的问题，这样就不会有两个皇后互相攻击。给定一个整数n，返回n皇后谜题的所有不同的解。每个解都包含n皇后位置的一个不同的板配置，其中‘Q’和‘.’都分别表示一个皇后和一个空间。例如，对于4皇后之谜，有两种不同的解决方案：</h4><pre><code>[
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, N-Queens</span><br><span class="line">// 深搜+剪枝</span><br><span class="line">// 时间复杂度O(n!*n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; C(n, -1);  // C[i]表示第i行皇后所在的列编号</span><br><span class="line">        dfs(C, result, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;C, vector&lt;vector&lt;string&gt; &gt; &amp;result, int row) &#123;</span><br><span class="line">        const int N = C.size();</span><br><span class="line">        if (row == N) &#123; // 终止条件，也是收敛条件，意味着找到了一个可行解</span><br><span class="line">            vector&lt;string&gt; solution;</span><br><span class="line">            for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">                string s(N, &apos;.&apos;);</span><br><span class="line">                for (int j = 0; j &lt; N; ++j) &#123;</span><br><span class="line">                    if (j == C[i]) s[j] = &apos;Q&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                solution.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; N; ++j) &#123;  // 扩展状态，一列一列的试</span><br><span class="line">            const bool ok = isValid(C, row, j);</span><br><span class="line">            if (!ok) continue;  // 剪枝，如果非法，继续尝试下一列</span><br><span class="line">            // 执行扩展动作</span><br><span class="line">            C[row] = j;</span><br><span class="line">            dfs(C, result, row + 1);</span><br><span class="line">            // 撤销动作</span><br><span class="line">            // C[row] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 能否在 (row, col) 位置放一个皇后.</span><br><span class="line">     * @param C 棋局</span><br><span class="line">     * @param row 当前正在处理的行，前面的行都已经放了皇后了</span><br><span class="line">     * @param col 当前列</span><br><span class="line">     * @return 能否放一个皇后</span><br><span class="line">     */</span><br><span class="line">    bool isValid(const vector&lt;int&gt; &amp;C, int row, int col) &#123;</span><br><span class="line">        for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">            // 在同一列</span><br><span class="line">            if (C[i] == col) return false;</span><br><span class="line">            // 在同一对角线上</span><br><span class="line">            if (abs(i - row) == abs(C[i] - col)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11分治法"><a href="#11分治法" class="headerlink" title="11分治法"></a>11分治法</h3><h4 id="11-1pow-x-n"><a href="#11-1pow-x-n" class="headerlink" title="11.1pow(x,n)"></a>11.1pow(x,n)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//LeetCode, Pow(x, n)</span><br><span class="line">// 二分法，$x^n = x^&#123;n/2&#125; * x^&#123;n/2&#125; * x^&#123;n\%2&#125;$</span><br><span class="line">// 时间复杂度 O(logn)，空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        if (n &lt; 0) return 1.0 / power(x, -n);</span><br><span class="line">        else return power(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    double power(double x, int n) &#123;</span><br><span class="line">        if (n == 0) return 1;</span><br><span class="line">        double v = power(x, n / 2);</span><br><span class="line">        if (n % 2 == 0) return v * v;</span><br><span class="line">        else return v * v * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">#### 11.2sqrt(int x)</span><br><span class="line"></span><br><span class="line">```angularjs</span><br><span class="line">// LeetCode, Sqrt(x)</span><br><span class="line">// 二分查找</span><br><span class="line">// 时间复杂度 O(logn)，空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int left = 1, right = x / 2;</span><br><span class="line">        int last_mid; // 记录最近一次的 mid</span><br><span class="line">        if (x &lt; 2) return x;</span><br><span class="line">        while(left &lt;= right) &#123;</span><br><span class="line">            const int mid = left + (right - left) / 2;</span><br><span class="line">            if(x / mid &gt; mid) &#123; // 不要用 x &gt; mid * mid，会溢出</span><br><span class="line">                left = mid + 1;</span><br><span class="line">                last_mid = mid;</span><br><span class="line">            &#125; else if(x / mid &lt; mid) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return last_mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="12贪心法"><a href="#12贪心法" class="headerlink" title="12贪心法"></a>12贪心法</h3><h4 id="12-1给定一个非负整数数组，您最初定位在数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳转长度。确定您是否能够到达最后一个索引。例如：a-2，3，1，1，4-，返回true-a-3，2，1，0，4-，返回false。"><a href="#12-1给定一个非负整数数组，您最初定位在数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳转长度。确定您是否能够到达最后一个索引。例如：a-2，3，1，1，4-，返回true-a-3，2，1，0，4-，返回false。" class="headerlink" title="12.1给定一个非负整数数组，您最初定位在数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳转长度。确定您是否能够到达最后一个索引。例如：a=[2，3，1，1，4]，返回true.a=[3，2，1，0，4]，返回false。"></a>12.1给定一个非负整数数组，您最初定位在数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳转长度。确定您是否能够到达最后一个索引。例如：a=[2，3，1，1，4]，返回true.a=[3，2，1，0，4]，返回false。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Jump Game</span><br><span class="line">// 思路1，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(const vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int reach = 1; // 最右能跳到哪里</span><br><span class="line">        for (int i = 0; i &lt; reach &amp;&amp; reach &lt; nums.size(); ++i)</span><br><span class="line">            reach = max(reach, i + 1 + nums[i]);</span><br><span class="line">        return reach &gt;= nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Jump Game</span><br><span class="line">// 思路2，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump (const vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) return true;</span><br><span class="line">        // 逆向下楼梯，最多能下到几层</span><br><span class="line">        int left_most = nums.size() - 1;</span><br><span class="line">        for (int i = nums.size() - 2; i &gt;= 0; --i)</span><br><span class="line">            if (i + nums[i] &gt;= left_most)</span><br><span class="line">                left_most = i;</span><br><span class="line">        return left_most == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Jump Game</span><br><span class="line">// 思路3，时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(const vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; f(nums.size(), 0);</span><br><span class="line">        f[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            f[i] = max(f[i - 1], nums[i - 1]) - 1;</span><br><span class="line">            if (f[i] &lt; 0) return false;;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[nums.size() - 1] &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="12-3假设您有一个数组，其中第一个元素是第一天给定股票的价格。如果只允许您完成最多一笔交易-即购买一只股票并卖出一股票-，那么设计一个算法来寻找最大利润。"><a href="#12-3假设您有一个数组，其中第一个元素是第一天给定股票的价格。如果只允许您完成最多一笔交易-即购买一只股票并卖出一股票-，那么设计一个算法来寻找最大利润。" class="headerlink" title="12.3假设您有一个数组，其中第一个元素是第一天给定股票的价格。如果只允许您完成最多一笔交易(即购买一只股票并卖出一股票)，那么设计一个算法来寻找最大利润。"></a>12.3假设您有一个数组，其中第一个元素是第一天给定股票的价格。如果只允许您完成最多一笔交易(即购买一只股票并卖出一股票)，那么设计一个算法来寻找最大利润。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Best Time to Buy and Sell Stock</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">        if (prices.size() &lt; 2) return 0;</span><br><span class="line">        int profit = 0; // 差价</span><br><span class="line">        int cur_min = prices[0]; // 当前最小</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            profit = max(profit, prices[i] - cur_min);</span><br><span class="line">            cur_min = min(cur_min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="12-4假设你有一个数组，其中第一个元素是第一天的股票价格。设计一个算法来找到最大利润。你可以完成任意多个交易-即买一股，多次卖出一股-。但是，你不能同时进行多个交易-也就是说，你必须在再次买进之前卖掉股票-。"><a href="#12-4假设你有一个数组，其中第一个元素是第一天的股票价格。设计一个算法来找到最大利润。你可以完成任意多个交易-即买一股，多次卖出一股-。但是，你不能同时进行多个交易-也就是说，你必须在再次买进之前卖掉股票-。" class="headerlink" title="12.4假设你有一个数组，其中第一个元素是第一天的股票价格。设计一个算法来找到最大利润。你可以完成任意多个交易(即买一股，多次卖出一股)。但是，你不能同时进行多个交易(也就是说，你必须在再次买进之前卖掉股票)。"></a>12.4假设你有一个数组，其中第一个元素是第一天的股票价格。设计一个算法来找到最大利润。你可以完成任意多个交易(即买一股，多次卖出一股)。但是，你不能同时进行多个交易(也就是说，你必须在再次买进之前卖掉股票)。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Best Time to Buy and Sell Stock II</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            int diff = prices[i] - prices[i - 1];</span><br><span class="line">            if (diff &gt; 0) sum += diff;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="12-5给定一个字符串，找出没有重复字符的最长子字符串的长度。例如，“abCabcbb”中没有重复字母的最长子字符串是“abc”，最长子字符串的长度为3，对于“bbbbb”，最长的子字符串为“b”，长度为1。"><a href="#12-5给定一个字符串，找出没有重复字符的最长子字符串的长度。例如，“abCabcbb”中没有重复字母的最长子字符串是“abc”，最长子字符串的长度为3，对于“bbbbb”，最长的子字符串为“b”，长度为1。" class="headerlink" title="12.5给定一个字符串，找出没有重复字符的最长子字符串的长度。例如，“abCabcbb”中没有重复字母的最长子字符串是“abc”，最长子字符串的长度为3，对于“bbbbb”，最长的子字符串为“b”，长度为1。"></a>12.5给定一个字符串，找出没有重复字符的最长子字符串的长度。例如，“abCabcbb”中没有重复字母的最长子字符串是“abc”，最长子字符串的长度为3，对于“bbbbb”，最长的子字符串为“b”，长度为1。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Longest Substring Without Repeating Characters</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">// 考虑非字母的情况</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        const int ASCII_MAX = 255;</span><br><span class="line">        int last[ASCII_MAX]; // 记录字符上次出现过的位置</span><br><span class="line">        int start = 0; // 记录当前子串的起始位置</span><br><span class="line">        fill(last, last + ASCII_MAX, -1); // 0也是有效位置，因此初始化为1</span><br><span class="line">        int max_len = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (last[s[i]] &gt;= start) &#123;</span><br><span class="line">                max_len = max(i - start, max_len);</span><br><span class="line">            start = last[s[i]] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            last[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return max((int)s.size() - start, max_len); // 最后一次，例如 &quot;abcd&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="12-6给定n个非负整数a1-a2-…-an，其中每个表示坐标-i-ai-上的一个点。n条垂直线的绘制使第一行的两个端点位于-i-ai-和-i-0-。找到两条线，与x轴一起形成一个容器，这样容器包含最多的水。注意：您不能倾斜容器。"><a href="#12-6给定n个非负整数a1-a2-…-an，其中每个表示坐标-i-ai-上的一个点。n条垂直线的绘制使第一行的两个端点位于-i-ai-和-i-0-。找到两条线，与x轴一起形成一个容器，这样容器包含最多的水。注意：您不能倾斜容器。" class="headerlink" title="12.6给定n个非负整数a1,a2,…,an，其中每个表示坐标(i,ai)上的一个点。n条垂直线的绘制使第一行的两个端点位于(i,ai)和(i,0)。找到两条线，与x轴一起形成一个容器，这样容器包含最多的水。注意：您不能倾斜容器。"></a>12.6给定n个非负整数a1,a2,…,an，其中每个表示坐标(i,ai)上的一个点。n条垂直线的绘制使第一行的两个端点位于(i,ai)和(i,0)。找到两条线，与x轴一起形成一个容器，这样容器包含最多的水。注意：您不能倾斜容器。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Container With Most Water</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt; &amp;height) &#123;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = height.size() - 1;</span><br><span class="line">        int result = INT_MIN;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            int area = min(height[end], height[start]) * (end - start);</span><br><span class="line">            result = max(result, area);</span><br><span class="line">            if (height[start] &lt;= height[end]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13动态规划"><a href="#13动态规划" class="headerlink" title="13动态规划"></a>13动态规划</h3><h4 id="13-1给定一个三角形，找出从上到下的最小路径和。每一步你都可以移动到下面行的相邻数。例如，给定以下三角形-2-，-3，4-，-6，5，7-，-4，1，8，3-，从上到下的最小路径和为11-即2-3-5-1-11-。注意：如果您只使用O-n-额外的空间就可以做到这一点，其中n是三角形中的行总数。"><a href="#13-1给定一个三角形，找出从上到下的最小路径和。每一步你都可以移动到下面行的相邻数。例如，给定以下三角形-2-，-3，4-，-6，5，7-，-4，1，8，3-，从上到下的最小路径和为11-即2-3-5-1-11-。注意：如果您只使用O-n-额外的空间就可以做到这一点，其中n是三角形中的行总数。" class="headerlink" title="13.1给定一个三角形，找出从上到下的最小路径和。每一步你都可以移动到下面行的相邻数。例如，给定以下三角形[2]，[3，4]，[6，5，7]，[4，1，8，3]，从上到下的最小路径和为11(即2+3+5+1=11)。注意：如果您只使用O(n)额外的空间就可以做到这一点，其中n是三角形中的行总数。"></a>13.1给定一个三角形，找出从上到下的最小路径和。每一步你都可以移动到下面行的相邻数。例如，给定以下三角形[2]，[3，4]，[6，5，7]，[4，1，8，3]，从上到下的最小路径和为11(即2+3+5+1=11)。注意：如果您只使用O(n)额外的空间就可以做到这一点，其中n是三角形中的行总数。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Triangle</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal (vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        for (int i = triangle.size() - 2; i &gt;= 0; --i)</span><br><span class="line">            for (int j = 0; j &lt; i + 1; ++j)</span><br><span class="line">                triangle[i][j] += min(triangle[i + 1][j],triangle[i + 1][j + 1]);</span><br><span class="line">        return triangle [0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-2在一个具有最大和的数组-至少包含一个数-中查找相邻子数组。例如，给定数组-−2，1，−3，4，−1，2，1，−5，4-，相邻子数组-4，−1，2，1-的和最大-6。"><a href="#13-2在一个具有最大和的数组-至少包含一个数-中查找相邻子数组。例如，给定数组-−2，1，−3，4，−1，2，1，−5，4-，相邻子数组-4，−1，2，1-的和最大-6。" class="headerlink" title="13.2在一个具有最大和的数组(至少包含一个数)中查找相邻子数组。例如，给定数组[−2，1，−3，4，−1，2，1，−5，4]，相邻子数组[4，−1，2，1]的和最大=6。"></a>13.2在一个具有最大和的数组(至少包含一个数)中查找相邻子数组。例如，给定数组[−2，1，−3，4，−1，2，1，−5，4]，相邻子数组[4，−1，2，1]的和最大=6。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Maximum Subarray</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result = INT_MIN, f = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            f = max(f + nums[i], nums[i]);</span><br><span class="line">            result = max(result, f);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Maximum Subarray</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        return mcss(A.begin(), A.end());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // 求最大连续子序列和</span><br><span class="line">    template &lt;typename Iter&gt;</span><br><span class="line">    static int mcss(Iter begin, Iter end) &#123;</span><br><span class="line">        int result, cur_min;</span><br><span class="line">        const int n = distance(begin, end);</span><br><span class="line">        int *sum = new int[n + 1]; // 前n项和</span><br><span class="line">        sum[0] = 0;</span><br><span class="line">        result = INT_MIN;</span><br><span class="line">        cur_min = sum[0];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - 1] + *(begin + i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            result = max(result, sum[i] - cur_min);</span><br><span class="line">            cur_min = min(cur_min, sum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        delete[] sum;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-3给定字符串s，分区s使得分区的每个子字符串都是回文。返回回文分区S所需的最小割集。例如，给定s-“AAB”，返回1，因为回文分区-“AA”，“b”-可以使用1-Cut生成。"><a href="#13-3给定字符串s，分区s使得分区的每个子字符串都是回文。返回回文分区S所需的最小割集。例如，给定s-“AAB”，返回1，因为回文分区-“AA”，“b”-可以使用1-Cut生成。" class="headerlink" title="13.3给定字符串s，分区s使得分区的每个子字符串都是回文。返回回文分区S所需的最小割集。例如，给定s=“AAB”，返回1，因为回文分区[“AA”，“b”]可以使用1 Cut生成。"></a>13.3给定字符串s，分区s使得分区的每个子字符串都是回文。返回回文分区S所需的最小割集。例如，给定s=“AAB”，返回1，因为回文分区[“AA”，“b”]可以使用1 Cut生成。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Palindrome Partitioning II</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(n^2)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCut(const string&amp; s) &#123;</span><br><span class="line">        const int n = s.size();</span><br><span class="line">        int f[n+1];</span><br><span class="line">        bool p[n][n];</span><br><span class="line">        fill_n(&amp;p[0][0], n * n, false);</span><br><span class="line">        //the worst case is cutting by each char</span><br><span class="line">        for (int i = 0; i &lt;= n; i++)</span><br><span class="line">        f[i] = n - 1 - i; // 最后一个 f[n]=-1</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i; j &lt; n; j++) &#123;</span><br><span class="line">                if (s[i] == s[j] &amp;&amp; (j - i &lt; 2 || p[i + 1][j - 1])) &#123;</span><br><span class="line">                    p[i][j] = true;</span><br><span class="line">                    f[i] = min(f[i], f[j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-4给定一个包含0和1的2D二进制矩阵，找到包含所有的最大矩形并返回其面积。"><a href="#13-4给定一个包含0和1的2D二进制矩阵，找到包含所有的最大矩形并返回其面积。" class="headerlink" title="13.4给定一个包含0和1的2D二进制矩阵，找到包含所有的最大矩形并返回其面积。"></a>13.4给定一个包含0和1的2D二进制矩阵，找到包含所有的最大矩形并返回其面积。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Maximal Rectangle</span><br><span class="line">// 时间复杂度O(n^2)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123;</span><br><span class="line">        if (matrix.empty()) return 0;</span><br><span class="line">        const int m = matrix.size();</span><br><span class="line">        const int n = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; H(n, 0);</span><br><span class="line">        vector&lt;int&gt; L(n, 0);</span><br><span class="line">        vector&lt;int&gt; R(n, n);</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            int left = 0, right = n;</span><br><span class="line">            // calculate L(i, j) from left to right</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (matrix[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    ++H[j];</span><br><span class="line">                    L[j] = max(L[j], left);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    left = j+1;</span><br><span class="line">                    H[j] = 0; L[j] = 0; R[j] = n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // calculate R(i, j) from right to left</span><br><span class="line">            for (int j = n-1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (matrix[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    R[j] = min(R[j], right);</span><br><span class="line">                    ret = max(ret, H[j]*(R[j]-L[j]));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-5假设你有一个数组，其中第i个元素是第i天给定股票的价格。设计一个算法来找到最大利润。你最多可以完成两个交易。注意：你不能同时进行多个交易-也就是说，你必须在再次买进之前卖掉股票-。"><a href="#13-5假设你有一个数组，其中第i个元素是第i天给定股票的价格。设计一个算法来找到最大利润。你最多可以完成两个交易。注意：你不能同时进行多个交易-也就是说，你必须在再次买进之前卖掉股票-。" class="headerlink" title="13.5假设你有一个数组，其中第i个元素是第i天给定股票的价格。设计一个算法来找到最大利润。你最多可以完成两个交易。注意：你不能同时进行多个交易(也就是说，你必须在再次买进之前卖掉股票)。"></a>13.5假设你有一个数组，其中第i个元素是第i天给定股票的价格。设计一个算法来找到最大利润。你最多可以完成两个交易。注意：你不能同时进行多个交易(也就是说，你必须在再次买进之前卖掉股票)。</h4><p>设状态<code>f(i)</code>，表示区间<code>[0,i] (0&lt;=i&lt;=n-1)</code>的最大利润，状态<code>g(i)</code>，表示区间<code>[i, n-1] (0&lt;=i&lt;=n-1)</code>的最大利润，则最终答案为<code>\max{f(i)+g(i)},0&lt;=i&lt;=n-1</code>。<br>允许在一天内买进又卖出，相当于不交易，因为题目的规定是最多两次，而不是一定要两次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Best Time to Buy and Sell Stock III</span><br><span class="line">// 时间复杂度O(n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if (prices.size() &lt; 2) return 0;</span><br><span class="line">        const int n = prices.size();</span><br><span class="line">        vector&lt;int&gt; f(n, 0);</span><br><span class="line">        vector&lt;int&gt; g(n, 0);</span><br><span class="line">        for (int i = 1, valley = prices[0]; i &lt; n; ++i) &#123;</span><br><span class="line">            valley = min(valley, prices[i]);</span><br><span class="line">            f[i] = max(f[i - 1], prices[i] - valley);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 2, peak = prices[n - 1]; i &gt;= 0; --i) &#123;</span><br><span class="line">            peak = max(peak, prices[i]);</span><br><span class="line">            g[i] = max(g[i], peak - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int max_profit = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">            max_profit = max(max_profit, f[i] + g[i]);</span><br><span class="line">        return max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-6给定s1-s2-s3，查找s3是否由s1和s2交织而成。例如，给定：s1-“aabc”，s2-“dbbca”，当s3-“aadbbcbcac”时，返回true。当s3-“aadbbbaccc”时，返回false。"><a href="#13-6给定s1-s2-s3，查找s3是否由s1和s2交织而成。例如，给定：s1-“aabc”，s2-“dbbca”，当s3-“aadbbcbcac”时，返回true。当s3-“aadbbbaccc”时，返回false。" class="headerlink" title="13.6给定s1,s2,s3，查找s3是否由s1和s2交织而成。例如，给定：s1=“aabc”，s2=“dbbca”，当s3=“aadbbcbcac”时，返回true。当s3=“aadbbbaccc”时，返回false。"></a>13.6给定s1,s2,s3，查找s3是否由s1和s2交织而成。例如，给定：s1=“aabc”，s2=“dbbca”，当s3=“aadbbcbcac”时，返回true。当s3=“aadbbbaccc”时，返回false。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Interleaving String</span><br><span class="line">// 递归，会超时，仅用来帮助理解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isInterleave(const string&amp; s1, const string&amp; s2, const string&amp; s3) &#123;</span><br><span class="line">        if (s3.length() != s1.length() + s2.length())</span><br><span class="line">            return false;</span><br><span class="line">        return isInterleave(begin(s1), end(s1), begin(s2), end(s2),</span><br><span class="line">                begin(s3), end(s3));</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename InIt&gt;</span><br><span class="line">    bool isInterleave(InIt first1, InIt last1, InIt first2, InIt last2,</span><br><span class="line">            InIt first3, InIt last3) &#123;</span><br><span class="line">        if (first3 == last3)</span><br><span class="line">            return first1 == last1 &amp;&amp; first2 == last2;</span><br><span class="line">        return (*first1 == *first3 &amp;&amp; isInterleave(next(first1), last1, first2, last2,next(first3), last3))</span><br><span class="line">                || (*first2 == *first3 &amp;&amp; isInterleave(first1, last1, next(first2), last2,next(first3), last3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Interleaving String</span><br><span class="line">// 二维动规，时间复杂度O(n^2)，空间复杂度O(n^2)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isInterleave(const string&amp; s1, const string&amp; s2, const string&amp; s3) &#123;</span><br><span class="line">        if (s3.length() != s1.length() + s2.length())</span><br><span class="line">            return false;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; f(s1.length() + 1,vector&lt;bool&gt;(s2.length() + 1, true));</span><br><span class="line">        for (size_t i = 1; i &lt;= s1.length(); ++i)</span><br><span class="line">            f[i][0] = f[i - 1][0] &amp;&amp; s1[i - 1] == s3[i - 1];</span><br><span class="line">        for (size_t i = 1; i &lt;= s2.length(); ++i)</span><br><span class="line">            f[0][i] = f[0][i - 1] &amp;&amp; s2[i - 1] == s3[i - 1];</span><br><span class="line">        for (size_t i = 1; i &lt;= s1.length(); ++i)</span><br><span class="line">            for (size_t j = 1; j &lt;= s2.length(); ++j)</span><br><span class="line">                f[i][j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; f[i - 1][j])||(s2[j - 1] == s3[i + j - 1] &amp;&amp; f[i][j - 1]);</span><br><span class="line">        return f[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Interleaving String</span><br><span class="line">// 二维动规+滚动数组，时间复杂度O(n^2)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isInterleave(const string&amp; s1, const string&amp; s2, const string&amp; s3) &#123;</span><br><span class="line">        if (s1.length() + s2.length() != s3.length())</span><br><span class="line">            return false;</span><br><span class="line">        if (s1.length() &lt; s2.length())</span><br><span class="line">            return isInterleave(s2, s1, s3);</span><br><span class="line">        vector&lt;bool&gt; f(s2.length() + 1, true);</span><br><span class="line">        for (size_t i = 1; i &lt;= s2.length(); ++i)</span><br><span class="line">            f[i] = s2[i - 1] == s3[i - 1] &amp;&amp; f[i - 1];</span><br><span class="line">        for (size_t i = 1; i &lt;= s1.length(); ++i) &#123;</span><br><span class="line">            f[0] = s1[i - 1] == s3[i - 1] &amp;&amp; f[0];</span><br><span class="line">            for (size_t j = 1; j &lt;= s2.length(); ++j)</span><br><span class="line">                f[j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; f[j])||(s2[j - 1] == s3[i + j - 1] &amp;&amp; f[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return f[s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-7给定一个字符串S1，我们可以通过递归地将它划分为两个非空子字符串来将它表示为二叉树。下面是S1-“great”的一种可能的表示形式：为了置乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。例如，如果我们选择节点“gr”并交换它的两个子节点，它会产生一个加扰字符串“rgeat”。我们说“rgeat”是一个“great”的置乱字符串，类似地，如果我们继续交换节点的子节点“Eat”和“at”，它会产生一个加扰字符串“rgtae”。我们说“rgtae”是一个“great”的置乱字符串，给定两个长度相同的字符串s1和s2，确定s2是否是s1的加扰字符串。"><a href="#13-7给定一个字符串S1，我们可以通过递归地将它划分为两个非空子字符串来将它表示为二叉树。下面是S1-“great”的一种可能的表示形式：为了置乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。例如，如果我们选择节点“gr”并交换它的两个子节点，它会产生一个加扰字符串“rgeat”。我们说“rgeat”是一个“great”的置乱字符串，类似地，如果我们继续交换节点的子节点“Eat”和“at”，它会产生一个加扰字符串“rgtae”。我们说“rgtae”是一个“great”的置乱字符串，给定两个长度相同的字符串s1和s2，确定s2是否是s1的加扰字符串。" class="headerlink" title="13.7给定一个字符串S1，我们可以通过递归地将它划分为两个非空子字符串来将它表示为二叉树。下面是S1=“great”的一种可能的表示形式：为了置乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。例如，如果我们选择节点“gr”并交换它的两个子节点，它会产生一个加扰字符串“rgeat”。我们说“rgeat”是一个“great”的置乱字符串，类似地，如果我们继续交换节点的子节点“Eat”和“at”，它会产生一个加扰字符串“rgtae”。我们说“rgtae”是一个“great”的置乱字符串，给定两个长度相同的字符串s1和s2，确定s2是否是s1的加扰字符串。"></a>13.7给定一个字符串S1，我们可以通过递归地将它划分为两个非空子字符串来将它表示为二叉树。下面是S1=“great”的一种可能的表示形式：为了置乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。例如，如果我们选择节点“gr”并交换它的两个子节点，它会产生一个加扰字符串“rgeat”。我们说“rgeat”是一个“great”的置乱字符串，类似地，如果我们继续交换节点的子节点“Eat”和“at”，它会产生一个加扰字符串“rgtae”。我们说“rgtae”是一个“great”的置乱字符串，给定两个长度相同的字符串s1和s2，确定s2是否是s1的加扰字符串。</h4><p><code>f[n][i][j]} = (f[k][i][j] &amp;&amp; f[n-k][i+k][j+k]) || (f[k][i][j+n-k] &amp;&amp; f[n-k][i+k][j])</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Scramble String</span><br><span class="line">// 递归，会超时，仅用来帮助理解</span><br><span class="line">// 时间复杂度O(n^6)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isScramble(const string&amp; s1, const string&amp; s2) &#123;</span><br><span class="line">        return isScramble(s1.begin(), s1.end(), s2.begin());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    typedef string::iterator Iterator;</span><br><span class="line">    bool isScramble(Iterator first1, Iterator last1, Iterator first2) &#123;</span><br><span class="line">        auto length = distance(first1, last1);</span><br><span class="line">        auto last2 = next(first2, length);</span><br><span class="line">        if (length == 1) return *first1 == *first2;</span><br><span class="line">        for (int i = 1; i &lt; length; ++i)</span><br><span class="line">            if ((isScramble(first1, first1 + i, first2)</span><br><span class="line">                 &amp;&amp; isScramble(first1 + i, last1, first2 + i))</span><br><span class="line">                    || (isScramble(first1, first1 + i, last2 - i)</span><br><span class="line">                            &amp;&amp; isScramble(first1 + i, last1, first2)))</span><br><span class="line">                return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Scramble String</span><br><span class="line">// 动规，时间复杂度O(n^3)，空间复杂度O(n^3)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isScramble(const string&amp; s1, const string&amp; s2) &#123;</span><br><span class="line">        const int N = s1.size();</span><br><span class="line">        if (N != s2.size()) return false;</span><br><span class="line">        // f[n][i][j]，表示长度为n，起点为s1[i]和</span><br><span class="line">        // 起点为s2[j]两个字符串是否互为scramble</span><br><span class="line">        bool f[N + 1][N][N];</span><br><span class="line">        fill_n(&amp;f[0][0][0], (N + 1) * N * N, false);</span><br><span class="line">        for (int i = 0; i &lt; N; i++)</span><br><span class="line">            for (int j = 0; j &lt; N; j++)</span><br><span class="line">                f[1][i][j] = s1[i] == s2[j];</span><br><span class="line">        for (int n = 1; n &lt;= N; ++n) &#123;</span><br><span class="line">            for (int i = 0; i + n &lt;= N; ++i) &#123;</span><br><span class="line">                for (int j = 0; j + n &lt;= N; ++j) &#123;</span><br><span class="line">                    for (int k = 1; k &lt; n; ++k) &#123;</span><br><span class="line">                        if ((f[k][i][j] &amp;&amp; f[n - k][i + k][j + k]) ||</span><br><span class="line">                                (f[k][i][j + n - k] &amp;&amp; f[n - k][i + k][j])) &#123;</span><br><span class="line">                            f[n][i][j] = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[N][0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Scramble String</span><br><span class="line">// 递归+剪枝</span><br><span class="line">// 时间复杂度O(n^6)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isScramble(const string&amp; s1, const string&amp; s2) &#123;</span><br><span class="line">        return isScramble(s1.begin(), s1.end(), s2.begin());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    typedef string::const_iterator Iterator;</span><br><span class="line">    bool isScramble(Iterator first1, Iterator last1, Iterator first2) &#123;</span><br><span class="line">        auto length = distance(first1, last1);</span><br><span class="line">        auto last2 = next(first2, length);</span><br><span class="line">        if (length == 1) return *first1 == *first2;</span><br><span class="line">        // 剪枝，提前返回</span><br><span class="line">        int A[26]; // 每个字符的计数器</span><br><span class="line">        fill(A, A + 26, 0);</span><br><span class="line">        for(int i = 0; i &lt; length; i++) A[*(first1+i)-&apos;a&apos;]++;</span><br><span class="line">        for(int i = 0; i &lt; length; i++) A[*(first2+i)-&apos;a&apos;]--;</span><br><span class="line">        for(int i = 0; i &lt; 26; i++) if (A[i] != 0) return false;</span><br><span class="line">        for (int i = 1; i &lt; length; ++i)</span><br><span class="line">            if ((isScramble(first1, first1 + i, first2)</span><br><span class="line">                 &amp;&amp; isScramble(first1 + i, last1, first2 + i))</span><br><span class="line">                    || (isScramble(first1, first1 + i, last2 - i)</span><br><span class="line">                            &amp;&amp; isScramble(first1 + i, last1, first2)))</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-8给定一个由非负数填充的m×n网格，从左上角到右下角寻找一条路径，使沿着其路径的所有数字之和最小化。注意：您只能在任何时间点向下或向右移动。"><a href="#13-8给定一个由非负数填充的m×n网格，从左上角到右下角寻找一条路径，使沿着其路径的所有数字之和最小化。注意：您只能在任何时间点向下或向右移动。" class="headerlink" title="13.8给定一个由非负数填充的m×n网格，从左上角到右下角寻找一条路径，使沿着其路径的所有数字之和最小化。注意：您只能在任何时间点向下或向右移动。"></a>13.8给定一个由非负数填充的m×n网格，从左上角到右下角寻找一条路径，使沿着其路径的所有数字之和最小化。注意：您只能在任何时间点向下或向右移动。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Minimum Path Sum</span><br><span class="line">// 备忘录法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123;</span><br><span class="line">        const int m = grid.size();</span><br><span class="line">        const int n = grid[0].size();</span><br><span class="line">        this-&gt;f = vector&lt;vector&lt;int&gt; &gt;(m, vector&lt;int&gt;(n, -1));</span><br><span class="line">        return dfs(grid, m-1, n-1);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; f;  // 缓存</span><br><span class="line">    int dfs(const vector&lt;vector&lt;int&gt; &gt; &amp;grid, int x, int y) &#123;</span><br><span class="line">        if (x &lt; 0 || y &lt; 0) return INT_MAX; // 越界，终止条件，注意，不是0</span><br><span class="line">        if (x == 0 &amp;&amp; y == 0) return grid[0][0]; // 回到起点，收敛条件</span><br><span class="line">        return min(getOrUpdate(grid, x - 1, y),</span><br><span class="line">                getOrUpdate(grid, x, y - 1)) + grid[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    int getOrUpdate(const vector&lt;vector&lt;int&gt; &gt; &amp;grid, int x, int y) &#123;</span><br><span class="line">        if (x &lt; 0 || y &lt; 0) return INT_MAX; // 越界，注意，不是0</span><br><span class="line">        if (f[x][y] &gt;= 0) return f[x][y];</span><br><span class="line">        else return f[x][y] = dfs(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Minimum Path Sum</span><br><span class="line">// 二维动规</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123;</span><br><span class="line">        if (grid.size() == 0) return 0;</span><br><span class="line">        const int m = grid.size();</span><br><span class="line">        const int n = grid[0].size();</span><br><span class="line">        int f[m][n];</span><br><span class="line">        f[0][0] = grid[0][0];</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            f[i][0] = f[i - 1][0] + grid[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            f[0][i] = f[0][i - 1] + grid[0][i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Minimum Path Sum</span><br><span class="line">// 二维动规+滚动数组</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123;</span><br><span class="line">        const int m = grid.size();</span><br><span class="line">        const int n = grid[0].size();</span><br><span class="line">        int f[n];</span><br><span class="line">        fill(f, f+n, INT_MAX); // 初始值是 INT_MAX，因为后面用了min函数。</span><br><span class="line">        f[0] = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            f[0] += grid[i][0];</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                // 左边的f[j]，表示更新后的f[j]，与公式中的f[i[[j]对应</span><br><span class="line">                // 右边的f[j]，表示老的f[j]，与公式中的f[i-1][j]对应</span><br><span class="line">                f[j] = min(f[j - 1], f[j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-9给定两个单词Word1和Word2，找到将Word1转换为Word2所需的最小步骤数。-每个操作都算作1步。-您可以对一个单词执行以下3个操作：插入一个字符，删除一个字符，替换一个字符"><a href="#13-9给定两个单词Word1和Word2，找到将Word1转换为Word2所需的最小步骤数。-每个操作都算作1步。-您可以对一个单词执行以下3个操作：插入一个字符，删除一个字符，替换一个字符" class="headerlink" title="13.9给定两个单词Word1和Word2，找到将Word1转换为Word2所需的最小步骤数。(每个操作都算作1步。)您可以对一个单词执行以下3个操作：插入一个字符，删除一个字符，替换一个字符"></a>13.9给定两个单词Word1和Word2，找到将Word1转换为Word2所需的最小步骤数。(每个操作都算作1步。)您可以对一个单词执行以下3个操作：插入一个字符，删除一个字符，替换一个字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Edit Distance</span><br><span class="line">// 二维动规，时间复杂度O(n*m)，空间复杂度O(n*m)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(const string &amp;word1, const string &amp;word2) &#123;</span><br><span class="line">        const size_t n = word1.size();</span><br><span class="line">        const size_t m = word2.size();</span><br><span class="line">        // 长度为n的字符串，有n+1个隔板</span><br><span class="line">        int f[n + 1][m + 1];</span><br><span class="line">        for (size_t i = 0; i &lt;= n; i++)</span><br><span class="line">            f[i][0] = i;</span><br><span class="line">        for (size_t j = 0; j &lt;= m; j++)</span><br><span class="line">            f[0][j] = j;</span><br><span class="line">        for (size_t i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (size_t j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">                if (word1[i - 1] == word2[j - 1])</span><br><span class="line">                    f[i][j] = f[i - 1][j - 1];</span><br><span class="line">                else &#123;</span><br><span class="line">                    int mn = min(f[i - 1][j], f[i][j - 1]);</span><br><span class="line">                    f[i][j] = 1 + min(f[i - 1][j - 1], mn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Edit Distance</span><br><span class="line">// 二维动规+滚动数组</span><br><span class="line">// 时间复杂度O(n*m)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(const string &amp;word1, const string &amp;word2) &#123;</span><br><span class="line">        if (word1.length() &lt; word2.length())</span><br><span class="line">            return minDistance(word2, word1);</span><br><span class="line">        int f[word2.length() + 1];</span><br><span class="line">        int upper_left = 0; // 额外用一个变量记录f[i-1][j-1]</span><br><span class="line">        for (size_t i = 0; i &lt;= word2.size(); ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">        for (size_t i = 1; i &lt;= word1.size(); ++i) &#123;</span><br><span class="line">            upper_left = f[0];</span><br><span class="line">            f[0] = i;</span><br><span class="line">            for (size_t j = 1; j &lt;= word2.size(); ++j) &#123;</span><br><span class="line">                int upper = f[j];</span><br><span class="line">                if (word1[i - 1] == word2[j - 1])</span><br><span class="line">                    f[j] = upper_left;</span><br><span class="line">                else</span><br><span class="line">                    f[j] = 1 + min(upper_left, min(f[j], f[j - 1]));</span><br><span class="line">                upper_left = upper;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-10一个包含来自AZ的字母的消息使用下面的映射被编码成数字：‘A’-gt-1，’B’-gt-2，…，’Z’-gt-26。给定包含数字的编码消息，确定解码方式的总数。例如，给定的编码消息“12”，可以解码为“ab”-1-2-或“l”-12-。解码“12”的方式数为2。"><a href="#13-10一个包含来自AZ的字母的消息使用下面的映射被编码成数字：‘A’-gt-1，’B’-gt-2，…，’Z’-gt-26。给定包含数字的编码消息，确定解码方式的总数。例如，给定的编码消息“12”，可以解码为“ab”-1-2-或“l”-12-。解码“12”的方式数为2。" class="headerlink" title="13.10一个包含来自AZ的字母的消息使用下面的映射被编码成数字：‘A’-&gt; 1，’B’ -&gt; 2，…，’Z’ -&gt; 26。给定包含数字的编码消息，确定解码方式的总数。例如，给定的编码消息“12”，可以解码为“ab”(1 2)或“l”(12)。解码“12”的方式数为2。"></a>13.10一个包含来自AZ的字母的消息使用下面的映射被编码成数字：‘A’-&gt; 1，’B’ -&gt; 2，…，’Z’ -&gt; 26。给定包含数字的编码消息，确定解码方式的总数。例如，给定的编码消息“12”，可以解码为“ab”(1 2)或“l”(12)。解码“12”的方式数为2。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Decode Ways</span><br><span class="line">// 动规，时间复杂度O(n)，空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(const string &amp;s) &#123;</span><br><span class="line">        if (s.empty() || s[0] == &apos;0&apos;) return 0;</span><br><span class="line">        int prev = 0;</span><br><span class="line">        int cur = 1;</span><br><span class="line">        // 长度为n的字符串，有 n+1个阶梯</span><br><span class="line">        for (size_t i = 1; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            if (s[i-1] == &apos;0&apos;) cur = 0;</span><br><span class="line">            if (i &lt; 2 || !(s[i - 2] == &apos;1&apos; ||</span><br><span class="line">                     (s[i - 2] == &apos;2&apos; &amp;&amp; s[i - 1] &lt;= &apos;6&apos;)))</span><br><span class="line">                prev = 0;</span><br><span class="line">            int tmp = cur;</span><br><span class="line">            cur = prev + cur;</span><br><span class="line">            prev = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-11给定字符串s和字符串t，计算s中t的不同子序列数。字符串的子序列是一个新字符串，它是通过删除一些字符-可以是零-而不干扰其余字符的相对位置而形成的新字符串。-也就是说，“ACE”是“ABCDE”的子序列，而“AEC”不是-。下面是一个例子：s-“rabbbit”，t-“rabbit”返回3。"><a href="#13-11给定字符串s和字符串t，计算s中t的不同子序列数。字符串的子序列是一个新字符串，它是通过删除一些字符-可以是零-而不干扰其余字符的相对位置而形成的新字符串。-也就是说，“ACE”是“ABCDE”的子序列，而“AEC”不是-。下面是一个例子：s-“rabbbit”，t-“rabbit”返回3。" class="headerlink" title="13.11给定字符串s和字符串t，计算s中t的不同子序列数。字符串的子序列是一个新字符串，它是通过删除一些字符(可以是零)而不干扰其余字符的相对位置而形成的新字符串。(也就是说，“ACE”是“ABCDE”的子序列，而“AEC”不是)。下面是一个例子：s=“rabbbit”，t=“rabbit”返回3。"></a>13.11给定字符串s和字符串t，计算s中t的不同子序列数。字符串的子序列是一个新字符串，它是通过删除一些字符(可以是零)而不干扰其余字符的相对位置而形成的新字符串。(也就是说，“ACE”是“ABCDE”的子序列，而“AEC”不是)。下面是一个例子：s=“rabbbit”，t=“rabbit”返回3。</h4><p>设状态为<code>f(i,j)</code>，表示<code>T[0,j]</code>在<code>S[0,i]</code>里出现的次数。首先，无论<code>S[i]</code>和<code>T[j]</code>是否相等，若不使用<code>S[i]</code>，则<code>f(i,j)=f(i-1,j)</code>；若<code>S[i]==T[j]</code>，则可以使用<code>S[i]</code>，此时<code>f(i,j)=f(i-1,j)+f(i-1, j-1)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Distinct Subsequences</span><br><span class="line">// 二维动规+滚动数组</span><br><span class="line">// 时间复杂度O(m*n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(const string &amp;S, const string &amp;T) &#123;</span><br><span class="line">        vector&lt;int&gt; f(T.size() + 1);</span><br><span class="line">        f[0] = 1;</span><br><span class="line">        for (int i = 0; i &lt; S.size(); ++i) &#123;</span><br><span class="line">            for (int j = T.size() - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                f[j + 1] += S[i] == T[j] ? f[j] : 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[T.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-12给定字符串s和单词字典，确定s是否可以分割成一个或多个字典单词的空格分隔序列。例如，给定s-“leetcode”，dict-“leet”，“code”-。返回true，因为“leetcode”可以分割为“leet-code”。"><a href="#13-12给定字符串s和单词字典，确定s是否可以分割成一个或多个字典单词的空格分隔序列。例如，给定s-“leetcode”，dict-“leet”，“code”-。返回true，因为“leetcode”可以分割为“leet-code”。" class="headerlink" title="13.12给定字符串s和单词字典，确定s是否可以分割成一个或多个字典单词的空格分隔序列。例如，给定s=“leetcode”，dict=[“leet”，“code”]。返回true，因为“leetcode”可以分割为“leet code”。"></a>13.12给定字符串s和单词字典，确定s是否可以分割成一个或多个字典单词的空格分隔序列。例如，给定s=“leetcode”，dict=[“leet”，“code”]。返回true，因为“leetcode”可以分割为“leet code”。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Word Break</span><br><span class="line">// 深搜，超时</span><br><span class="line">// 时间复杂度O(2^n)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        return dfs(s, dict, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static bool dfs(const string &amp;s, unordered_set&lt;string&gt; &amp;dict,</span><br><span class="line">            size_t start, size_t cur) &#123;</span><br><span class="line">        if (cur == s.size()) &#123;</span><br><span class="line">            return dict.find(s.substr(start, cur-start+1)) != dict.end();</span><br><span class="line">        &#125;</span><br><span class="line">        if (dfs(s, dict, start, cur+1)) return true;</span><br><span class="line">        if (dict.find(s.substr(start, cur-start+1)) != dict.end())</span><br><span class="line">            if (dfs(s, dict, cur+1, cur+1)) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Word Break</span><br><span class="line">// 动规，时间复杂度O(n^2)，空间复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        // 长度为n的字符串有n+1个隔板</span><br><span class="line">        vector&lt;bool&gt; f(s.size() + 1, false);</span><br><span class="line">        f[0] = true; // 空字符串</span><br><span class="line">        for (int i = 1; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (f[j] &amp;&amp; dict.find(s.substr(j, i - j)) != dict.end()) &#123;</span><br><span class="line">                    f[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13-13给定字符串s和单词字典，在s中添加空格以构造一个句子，其中每个单词都是有效的字典词。返回所有这样的语句。例如，给定s-“catsanddog”，dict-“cat”-“cats”-“and”-“sand”-“dog”-。一个解决方案是-“cats-and-dog”-“cat-sand-dog”-。"><a href="#13-13给定字符串s和单词字典，在s中添加空格以构造一个句子，其中每个单词都是有效的字典词。返回所有这样的语句。例如，给定s-“catsanddog”，dict-“cat”-“cats”-“and”-“sand”-“dog”-。一个解决方案是-“cats-and-dog”-“cat-sand-dog”-。" class="headerlink" title="13.13给定字符串s和单词字典，在s中添加空格以构造一个句子，其中每个单词都是有效的字典词。返回所有这样的语句。例如，给定s = “catsanddog”，dict = [“cat”, “cats”, “and”, “sand”, “dog”]。一个解决方案是[“cats and dog”, “cat sand dog”]。"></a>13.13给定字符串s和单词字典，在s中添加空格以构造一个句子，其中每个单词都是有效的字典词。返回所有这样的语句。例如，给定s = “catsanddog”，dict = [“cat”, “cats”, “and”, “sand”, “dog”]。一个解决方案是[“cats and dog”, “cat sand dog”]。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// LeetCode, Word Break II</span><br><span class="line">// 动规，时间复杂度O(n^2)，空间复杂度O(n^2)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        // 长度为n的字符串有n+1个隔板</span><br><span class="line">        vector&lt;bool&gt; f(s.length() + 1, false);</span><br><span class="line">        // prev[i][j]为true，表示s[j, i)是一个合法单词，可以从j处切开</span><br><span class="line">        // 第一行未用</span><br><span class="line">        vector&lt;vector&lt;bool&gt; &gt; prev(s.length() + 1, vector&lt;bool&gt;(s.length()));</span><br><span class="line">        f[0] = true;</span><br><span class="line">        for (size_t i = 1; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (f[j] &amp;&amp; dict.find(s.substr(j, i - j)) != dict.end()) &#123;</span><br><span class="line">                    f[i] = true;</span><br><span class="line">                    prev[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;string&gt; path;</span><br><span class="line">        gen_path(s, prev, s.length(), path, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // DFS遍历树，生成路径</span><br><span class="line">    void gen_path(const string &amp;s, const vector&lt;vector&lt;bool&gt; &gt; &amp;prev,</span><br><span class="line">            int cur, vector&lt;string&gt; &amp;path, vector&lt;string&gt; &amp;result) &#123;</span><br><span class="line">        if (cur == 0) &#123;</span><br><span class="line">            string tmp;</span><br><span class="line">            for (auto iter = path.crbegin(); iter != path.crend(); ++iter)</span><br><span class="line">                tmp += *iter + &quot; &quot;;</span><br><span class="line">            tmp.erase(tmp.end() - 1);</span><br><span class="line">            result.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        for (size_t i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (prev[cur][i]) &#123;</span><br><span class="line">                path.push_back(s.substr(i, cur - i));</span><br><span class="line">                gen_path(s, prev, i, path, result);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/io/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/io/2018/07/18/Spanish/" rel="next" title="Spanish">
                <i class="fa fa-chevron-left"></i> Spanish
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/io/2018/07/20/bfsanddfs/" rel="prev" title="bfs&dfs">
                bfs&dfs <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/07/18/Leetcode/"
           data-title="Leetcode" data-url="http://dty075.coding.me/io/2018/07/18/Leetcode/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/io/images/flower.png"
               alt="dty075" />
          <p class="site-author-name" itemprop="name">dty075</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/io/archives/">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/io/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/io/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/dty075" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://coding.net/user" target="_blank" title="Coding">
                  
                    <i class="fa fa-fw fa-skype"></i>
                  
                    
                      Coding
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2线性表"><span class="nav-number">1.</span> <span class="nav-text">2线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1数组"><span class="nav-number">2.</span> <span class="nav-text">2.1数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1给定一个排序数组，移除已放置的重复项，使每个元素只出现一次并返回新的长度。"><span class="nav-number">2.1.</span> <span class="nav-text">2.1.1给定一个排序数组，移除已放置的重复项，使每个元素只出现一次并返回新的长度。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2跟进“删除重复”：如果复制最多允许两次？"><span class="nav-number">2.2.</span> <span class="nav-text">2.1.2跟进“删除重复”：如果复制最多允许两次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3假设一个排序的数组在你事先不知道的某个枢轴旋转。-例如，0-1-2-4-5-6-7可能变成4-5-6-7-0-1-2-。给你一个目标值进行搜索。如果在数组中找到它的索引，否则返回-1。你可能假设数组中没有重复。"><span class="nav-number">2.3.</span> <span class="nav-text">2.1.3假设一个排序的数组在你事先不知道的某个枢轴旋转。(例如，0 1 2 4 5 6 7可能变成4 5 6 7 0 1 2)。给你一个目标值进行搜索。如果在数组中找到它的索引，否则返回-1。你可能假设数组中没有重复。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4跟进“旋转排序数组中的搜索”：如果允许重复的话怎么办？这会影响运行时的复杂性吗？如何和为什么？编写一个函数来确定给定的目标是否在数组中。"><span class="nav-number">2.4.</span> <span class="nav-text">2.1.4跟进“旋转排序数组中的搜索”：如果允许重复的话怎么办？这会影响运行时的复杂性吗？如何和为什么？编写一个函数来确定给定的目标是否在数组中。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5有两个大小分别为m和n的排序数组a和b。找到两个排序数组的中间值。总的运行时复杂度应该是O-log-m-n-。"><span class="nav-number">2.5.</span> <span class="nav-text">2.1.5有两个大小分别为m和n的排序数组a和b。找到两个排序数组的中间值。总的运行时复杂度应该是O(log(m+n))。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6给定一个未排序的整数数组，找到最长的连续元素序列的长度。例如，给定-100，4，200，1，3，2-，最长的连续元素序列是-1，2，3，4-。返回它的长度：4。您的算法应该以O-n-复杂度运行。"><span class="nav-number">2.6.</span> <span class="nav-text">2.1.6给定一个未排序的整数数组，找到最长的连续元素序列的长度。例如，给定[100，4，200，1，3，2]，最长的连续元素序列是[1，2，3，4]。返回它的长度：4。您的算法应该以O(n)复杂度运行。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-7给定一个整数数组，找到两个数字，使它们相加成一个特定的目标数。函数twoSum应该返回两个数字的索引，以便它们加到目标，其中index1必须小于index2。请注意，返回的答案-index1和index2-都不是基于零的。你可以假设每个输入都有一个精确的解。输入：数字＝-2-7-11-15-，目标＝9-输出：index1＝1，index2＝2"><span class="nav-number">2.7.</span> <span class="nav-text">2.1.7给定一个整数数组，找到两个数字，使它们相加成一个特定的目标数。函数twoSum应该返回两个数字的索引，以便它们加到目标，其中index1必须小于index2。请注意，返回的答案(index1和index2)都不是基于零的。你可以假设每个输入都有一个精确的解。输入：数字＝{2,7,11,15}，目标＝9 输出：index1＝1，index2＝2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-8给定n个整数的数组S，其中是否有元素a-b-c使a-b-c-0？查找数组中给出零和的所有唯一三元组。注意：·三元组-a-b-c-必须是非降序的。-即，a≤b≤c-·解集不能包含重复的三元组。例如，给定数组s-1-0-1-2-1-1-4-，解集为：-1-0-1-1-1-2"><span class="nav-number">2.8.</span> <span class="nav-text">2.1.8给定n个整数的数组S，其中是否有元素a,b,c使a+b+c=0？查找数组中给出零和的所有唯一三元组。注意：·三元组(a,b,c)必须是非降序的。(即，a≤b≤c)·解集不能包含重复的三元组。例如，给定数组s={-1 0 1 2-1-1-4}，解集为：(-1,0,1)(-1,-1,2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-9给定n个整数的数组，在S中找到三个整数，使得和最接近一个给定的数，target。返回这三个整数的和。您可以假设每个输入都有一个解。例如，给定数组s-1-2-1-4-，target-1。与目标最接近的和是2。-1-2-1-2-。"><span class="nav-number">2.9.</span> <span class="nav-text">2.1.9给定n个整数的数组，在S中找到三个整数，使得和最接近一个给定的数，target。返回这三个整数的和。您可以假设每个输入都有一个解。例如，给定数组s={-1 2 1-4}，target=1。与目标最接近的和是2。(-1+2+1=2)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-10给定n个整数的数组S，其中是否有a-b-c和d元素使得a-b-c-d-target？找到数组中所有给出目标和的唯一四重元。注意：-元素在四重集-a-b-c-d-中必须是非降序的。-即，a≤b≤c≤d-·解集。例如，给定数组s-1-0-1-0-2-2-，target-0。解集为：-1-0-0-1-2-1-1-2-2-0-0-2"><span class="nav-number">2.10.</span> <span class="nav-text">2.1.10给定n个整数的数组S，其中是否有a,b,c和d元素使得a+b+c+d=target？找到数组中所有给出目标和的唯一四重元。注意：.元素在四重集(a,b,c,d)中必须是非降序的。(即，a≤b≤c≤d)·解集。例如，给定数组s={1 0-1 0-2 2}，target=0。解集为：(-1,0,0,1)(-2,-1,1,2)(-2,0,0,2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-11给定一个数组和一个值，移除该值的所有实例并返回新的长度。元素的顺序可以更改。"><span class="nav-number">2.11.</span> <span class="nav-text">2.1.11给定一个数组和一个值，移除该值的所有实例并返回新的长度。元素的顺序可以更改。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-12实现下一个排列，它在字典上将数字重新排列成更大的编号排列。如果这种排列不可能，它必须按照最低可能的顺序-即按升序排序-重新排列。替换必须就位，不要分配额外的内存。以下是一些例子。输入在左边的列中，相应的输出在右边的列中。"><span class="nav-number">2.12.</span> <span class="nav-text">2.1.12实现下一个排列，它在字典上将数字重新排列成更大的编号排列。如果这种排列不可能，它必须按照最低可能的顺序(即按升序排序)重新排列。替换必须就位，不要分配额外的内存。以下是一些例子。输入在左边的列中，相应的输出在右边的列中。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-13集合-1-2-3，…，n-总共包含n！唯一排列。通过列出和标记所有排列顺序，我们得到下面的序列（即n＝3）：“123”132“213”231“312”321“给定n和k，返回第k个排列顺序。注：给定n将包含在1和9之间。"><span class="nav-number">2.13.</span> <span class="nav-text">2.1.13集合[1,2,3，…，n]总共包含n！唯一排列。通过列出和标记所有排列顺序，我们得到下面的序列（即n＝3）：“123”132“213”231“312”321“给定n和k，返回第k个排列顺序。注：给定n将包含在1和9之间。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-14根据：Sudoku谜题-规则http：-sudoku-com-au-therules-aspx-确定sudoku是否有效。sudoku板可以部分填充，空单元格中填充字符“-”。"><span class="nav-number">2.14.</span> <span class="nav-text">2.1.14根据：Sudoku谜题-规则http：/sudoku.com.au/therules.aspx-确定sudoku是否有效。sudoku板可以部分填充，空单元格中填充字符“.”。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-15如果n个非负整数表示一个标高图，其中每个杆的宽度为1，计算它在下雨后能陷多少水。例如，给定-0，1，0，2，1，1，1，3，2，1，1-，返回6。"><span class="nav-number">2.15.</span> <span class="nav-text">2.1.15如果n个非负整数表示一个标高图，其中每个杆的宽度为1，计算它在下雨后能陷多少水。例如，给定[0，1，0，2，1，1，1，3，2，1，1]，返回6。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-16给你一个表示图像的n×n的2D矩阵。将图像旋转90度-顺时针方向-。跟进：你能在适当的地方做这个吗？"><span class="nav-number">2.16.</span> <span class="nav-text">2.1.16给你一个表示图像的n×n的2D矩阵。将图像旋转90度(顺时针方向)。跟进：你能在适当的地方做这个吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-17给定一个数字，表示为一个数字数组，再加上一个数字。（高精度加法）"><span class="nav-number">2.17.</span> <span class="nav-text">2.1.17给定一个数字，表示为一个数字数组，再加上一个数字。（高精度加法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-18你在爬楼梯。爬到山顶需要n步。每次你都可以爬1或2个台阶。你能用多少种不同的方式爬到山顶？"><span class="nav-number">2.18.</span> <span class="nav-text">2.1.18你在爬楼梯。爬到山顶需要n步。每次你都可以爬1或2个台阶。你能用多少种不同的方式爬到山顶？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-19Grey代码是一个二进制数字系统，其中两个连续值仅相差一位。给定一个非负整数n表示代码中的总位数，则打印Grey码序列。Grey代码序列必须以0开头。例如，给定n-2，返回-0，1，3，2-。它的Grey代码序列是：注：·对于给定的n，Grey代码序列不是唯一定义的。·例如，-0，2，3，1-也是根据上述定义有效的灰色代码序列。·目前，法官能够根据Grey代码序列的一个实例进行判断。"><span class="nav-number">2.19.</span> <span class="nav-text">2.1.19Grey代码是一个二进制数字系统，其中两个连续值仅相差一位。给定一个非负整数n表示代码中的总位数，则打印Grey码序列。Grey代码序列必须以0开头。例如，给定n=2，返回[0，1，3，2]。它的Grey代码序列是：注：·对于给定的n，Grey代码序列不是唯一定义的。·例如，[0，2，3，1]也是根据上述定义有效的灰色代码序列。·目前，法官能够根据Grey代码序列的一个实例进行判断。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-20给定m×n矩阵，如果元素为0，则将其整行和列设置为0。把它放在适当的位置。你有多余的空间吗？使用O（mn）空间的直截了当的解决方案可能是个坏主意。一个简单的改进使用O（m-n）空间，但仍然不是最好的解决方案。你能设计出一个恒定的空间解决方案吗？"><span class="nav-number">2.20.</span> <span class="nav-text">2.1.20给定m×n矩阵，如果元素为0，则将其整行和列设置为0。把它放在适当的位置。你有多余的空间吗？使用O（mn）空间的直截了当的解决方案可能是个坏主意。一个简单的改进使用O（m+n）空间，但仍然不是最好的解决方案。你能设计出一个恒定的空间解决方案吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-21在一个环形路线上有N个加油站，第i站的汽油量是gas-i-。你有一辆有一个无限制油箱的汽车，从第i站到下一站-i-1-要cost-i-煤气费。你从加油站的一个空油箱开始旅程。如果可以绕电路一圈的话，请返回起始加油站的指数，否则返回-1。注意：解决方案保证是唯一的。"><span class="nav-number">2.21.</span> <span class="nav-text">2.1.21在一个环形路线上有N个加油站，第i站的汽油量是gas[i]。你有一辆有一个无限制油箱的汽车，从第i站到下一站(i+1)要cost[i]煤气费。你从加油站的一个空油箱开始旅程。如果可以绕电路一圈的话，请返回起始加油站的指数，否则返回-1。注意：解决方案保证是唯一的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-22有N个孩子站成一排。每个孩子都被分配一个评级值。你给糖果的孩子们有以下要求：每个孩子必须至少有一个糖果。具有较高等级的孩子比邻居得到更多糖果。你必须给的最小糖果是多少？"><span class="nav-number">2.22.</span> <span class="nav-text">2.1.22有N个孩子站成一排。每个孩子都被分配一个评级值。你给糖果的孩子们有以下要求：每个孩子必须至少有一个糖果。具有较高等级的孩子比邻居得到更多糖果。你必须给的最小糖果是多少？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-23给定一个整数数组，每个元素都会出现两次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？"><span class="nav-number">2.23.</span> <span class="nav-text">2.1.23给定一个整数数组，每个元素都会出现两次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-24给定一个整数数组，每个元素都会出现三次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？"><span class="nav-number">2.24.</span> <span class="nav-text">2.1.24给定一个整数数组，每个元素都会出现三次，除了一个。找到单个元素。注意：您的算法应该具有线性运行时复杂性。您能不使用额外的内存来实现它吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2单链表"><span class="nav-number">3.</span> <span class="nav-text">2.2单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1给出两个表示两个非负数的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。添加两个数字并将其作为链表返回。输入：（2～4～3）（5～6～4）输出：7～0～8"><span class="nav-number">3.1.</span> <span class="nav-text">*2.2.1给出两个表示两个非负数的链表。这些数字以相反的顺序存储，每个节点都包含一个数字。添加两个数字并将其作为链表返回。输入：（2～4～3）（5～6～4）输出：7～0～8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2将链表从位置m反转到N。就地并一次通过。例如：给定1-gt-2-gt-3-gt-4-gt-5-gt-nullptr，m-2，n-4，返回1-gt-4-gt-3-gt-2-gt-5-gt-nullptr。注：给定m，n满足以下条件：1≤m≤n≤长度。"><span class="nav-number">3.2.</span> <span class="nav-text">2.2.2将链表从位置m反转到N。就地并一次通过。例如：给定1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr，m=2，n=4，返回1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;nullptr。注：给定m，n满足以下条件：1≤m≤n≤长度。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3给定一个链表和一个值x，将其划分为所有小于x的节点都在大于或等于x的节点之前。您应该保持两个分区中节点的原始相对顺序。例如，给定1-gt-4-gt-3-gt-2-gt-5-gt-2和x-3，返回1-gt-2-gt-2-gt-4-gt-3-gt-5。"><span class="nav-number">3.3.</span> <span class="nav-text">2.2.3给定一个链表和一个值x，将其划分为所有小于x的节点都在大于或等于x的节点之前。您应该保持两个分区中节点的原始相对顺序。例如，给定1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2和x=3，返回1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4给定一个排序链接列表，删除所有重复项，使每个元素只出现一次。例如，给定1-gt-1-gt-2，返回1-gt-2，给定1-gt-1-gt-2-gt-3，返回1-gt-2-gt-3"><span class="nav-number">3.4.</span> <span class="nav-text">2.3.4给定一个排序链接列表，删除所有重复项，使每个元素只出现一次。例如，给定1-&gt;1-&gt;2，返回1-&gt;2，给定1-&gt;1-&gt;2-&gt;3，返回1-&gt;2-&gt;3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5给定一个排序链接列表，删除所有重复编号的节点，只从原始列表中留下不同的编号。例如，给定1-gt-2-gt-3-gt-3-gt-4-gt-4-gt-5，返回1-gt-2-gt-5，给定1-gt-1-gt-1-gt-2-gt-3，返回2-gt-3。"><span class="nav-number">3.5.</span> <span class="nav-text">2.2.5给定一个排序链接列表，删除所有重复编号的节点，只从原始列表中留下不同的编号。例如，给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5，返回1-&gt;2-&gt;5，给定1-&gt;1-&gt;1-&gt;2-&gt;3，返回2-&gt;3。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6给定一个列表，按k个位置向右旋转列表，其中k是非负的。例如：给定1＞2＞3＞4＞5＞nullptr和k＝2，返回4＞5＞1＞2＞3＞nullptr。"><span class="nav-number">3.6.</span> <span class="nav-text">2.2.6给定一个列表，按k个位置向右旋转列表，其中k是非负的。例如：给定1＞2＞3＞4＞5＞nullptr和k＝2，返回4＞5＞1＞2＞3＞nullptr。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-7给定一个链表，从列表的末尾移除第n个节点并返回它的头。例如，给定的链表：1-gt-2-gt-3-gt-4-gt-5，和n-2。在从末尾移除第二个节点后，链接列表变成1-gt-2-gt-3-gt-5。注意：·给定n将始终有效。·尝试在一次传递中这样做。"><span class="nav-number">3.7.</span> <span class="nav-text">2.2.7给定一个链表，从列表的末尾移除第n个节点并返回它的头。例如，给定的链表：1-&gt;2-&gt;3-&gt;4-&gt;5，和n=2。在从末尾移除第二个节点后，链接列表变成1-&gt;2-&gt;3-&gt;5。注意：·给定n将始终有效。·尝试在一次传递中这样做。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-8给定一个链表，每两个相邻的节点交换一次，然后返回它的头。例如，给定1-gt-2-gt-3-gt-4，您应该将列表返回为2-gt-1-gt-4-gt-3。您的算法应该只使用常量空间。您可以不修改列表中的值，只能更改节点本身。"><span class="nav-number">3.8.</span> <span class="nav-text">2.2.8给定一个链表，每两个相邻的节点交换一次，然后返回它的头。例如，给定1-&gt;2-&gt;3-&gt;4，您应该将列表返回为2-&gt;1-&gt;4-&gt;3。您的算法应该只使用常量空间。您可以不修改列表中的值，只能更改节点本身。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-9给定一个链表，一次倒转链表k的节点并返回其修改后的列表。如果节点数不是k的倍数，那么最后的退出节点应该保持原样。您可以不改变节点中的值，只能更改节点本身。只分配常量内存。例如，给定这个链接列表：1-gt-2-gt-3-gt-4-gt-5：K-2，你应该返回：2-gt-1-gt-4-gt-3-gt-5；k-3，你应该返回：3-gt-2-gt-1-gt-4-gt-5"><span class="nav-number">3.9.</span> <span class="nav-text">2.2.9给定一个链表，一次倒转链表k的节点并返回其修改后的列表。如果节点数不是k的倍数，那么最后的退出节点应该保持原样。您可以不改变节点中的值，只能更改节点本身。只分配常量内存。例如，给定这个链接列表：1-&gt;2-&gt;3-&gt;4-&gt;5：K=2，你应该返回：2-&gt;1-&gt;4-&gt;3-&gt;5；k=3，你应该返回：3-&gt;2-&gt;1-&gt;4-&gt;5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-10给出一个链表，使每个节点包含一个额外的随机指针，该指针可以指向列表中的任何节点或空。返回列表的深度副本。"><span class="nav-number">3.10.</span> <span class="nav-text">2.2.10给出一个链表，使每个节点包含一个额外的随机指针，该指针可以指向列表中的任何节点或空。返回列表的深度副本。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-11给出一个链表，确定它是否有一个循环。跟进：你能不用额外的空间来解决它吗？"><span class="nav-number">3.11.</span> <span class="nav-text">2.2.11给出一个链表，确定它是否有一个循环。跟进：你能不用额外的空间来解决它吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-12给定一个链接列表，返回循环开始的节点。如果没有循环，返回空。后续：您可以不使用额外的空间来解决它吗？"><span class="nav-number">3.12.</span> <span class="nav-text">2.2.12给定一个链接列表，返回循环开始的节点。如果没有循环，返回空。后续：您可以不使用额外的空间来解决它吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-13给定一个单链接列表l：L0-gt-L1-gt-··-gt-Ln−1-gt-Ln，将其重新排序为：L0-gt-Ln-gt-L1-gt-Ln-1-gt-L2-gt-Ln−2-gt-···您必须在不改变节点值的情况下执行此操作。例如，给定-1，2，3，4-，将其重新排序为-1，4，2，3-。"><span class="nav-number">3.13.</span> <span class="nav-text">2.2.13给定一个单链接列表l：L0-&gt;L1-&gt;··-&gt;Ln−1-&gt;Ln，将其重新排序为：L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln−2-&gt;···您必须在不改变节点值的情况下执行此操作。例如，给定{1，2，3，4}，将其重新排序为{1，4，2，3}。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-14为最近使用最少的-LRU-缓存设计和实现一个数据结构。它应该支持以下操作：get和set。get-key-如果键存在于缓存中，则获取键的值-始终为正-，否则返回-1-set-key，value-如果密钥尚未显示，则设置或插入值。当缓存达到其容量时，它应该在插入新项之前使最近使用最少的项无效。"><span class="nav-number">3.14.</span> <span class="nav-text">2.2.14为最近使用最少的(LRU)缓存设计和实现一个数据结构。它应该支持以下操作：get和set。get(key)-如果键存在于缓存中，则获取键的值(始终为正)，否则返回-1.set(key，value)-如果密钥尚未显示，则设置或插入值。当缓存达到其容量时，它应该在插入新项之前使最近使用最少的项无效。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3字符串"><span class="nav-number">4.</span> <span class="nav-text">3字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1给定一个字符串，确定它是否是回文，只考虑字母数字字符，忽略情况。例如，“A-man-a-plan-a-canal-Panama”是回文。“race-a-car”不是回文。注意：你认为字符串可能是空的吗？这是一个很好的问题，在面试时可以问。为了解决这个问题，我们把空字符串定义为有效的回文。–125"><span class="nav-number">4.1.</span> <span class="nav-text">3.1给定一个字符串，确定它是否是回文，只考虑字母数字字符，忽略情况。例如，“A man, a plan, a canal: Panama”是回文。“race a car”不是回文。注意：你认为字符串可能是空的吗？这是一个很好的问题，在面试时可以问。为了解决这个问题，我们把空字符串定义为有效的回文。–125</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2实现strStr-。返回一个指针，指向haystack中needle的第一次出现，如果needle不是haystack的一部分，则为NULL。–28"><span class="nav-number">4.2.</span> <span class="nav-text">3.2实现strStr()。返回一个指针，指向haystack中needle的第一次出现，如果needle不是haystack的一部分，则为NULL。–28</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3实现atoi将字符串转换为整数。提示：仔细考虑所有可能的输入情况。如果您想要询问，请不要看到下面的问题，并问自己可能的输入用例是什么。注意：这个问题的目的是模糊地指定-即，没有给定的输入规格-。您负责收集所有的输入要求。在找到第一个非空格字符之前，尽可能多地使用空格字符。然后，从这个字符开始，取一个可选的正负号，后面跟着尽可能多的数字，并将它们解释为一个数值。字符串可以在构成整数的字符之后包含其他字符，这些字符被忽略，对此函数的行为没有任何影响。如果str中的第一个非空白字符序列不是有效整数，或者由于str为空或它只包含空白字符而不存在这种序列，则不进行转换。如果无法执行有效的转换，则返回一个零值。如果正确的值超出可表示值的范围，则返回int-max-2147483647-或int-min-2147483648-。"><span class="nav-number">4.3.</span> <span class="nav-text">3.3实现atoi将字符串转换为整数。提示：仔细考虑所有可能的输入情况。如果您想要询问，请不要看到下面的问题，并问自己可能的输入用例是什么。注意：这个问题的目的是模糊地指定(即，没有给定的输入规格)。您负责收集所有的输入要求。在找到第一个非空格字符之前，尽可能多地使用空格字符。然后，从这个字符开始，取一个可选的正负号，后面跟着尽可能多的数字，并将它们解释为一个数值。字符串可以在构成整数的字符之后包含其他字符，这些字符被忽略，对此函数的行为没有任何影响。如果str中的第一个非空白字符序列不是有效整数，或者由于str为空或它只包含空白字符而不存在这种序列，则不进行转换。如果无法执行有效的转换，则返回一个零值。如果正确的值超出可表示值的范围，则返回int_max(2147483647)或int_min(-2147483648)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4给定两个二进制字符串，返回它们的和-也是二进制字符串-。例如，a-”11”b-”1”返回”100”。"><span class="nav-number">4.4.</span> <span class="nav-text">3.4给定两个二进制字符串，返回它们的和(也是二进制字符串)。例如，a=”11”b=”1”返回”100”。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5给定一个字符串S，查找S中最长的回文子字符串，您可能假设s的最大长度为1000，并且存在一个唯一的最长回文子字符串。"><span class="nav-number">4.5.</span> <span class="nav-text">3.5给定一个字符串S，查找S中最长的回文子字符串，您可能假设s的最大长度为1000，并且存在一个唯一的最长回文子字符串。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6实现正则表达式匹配，支持”-”和”-“。”-”匹配任何单个字符。”-“匹配前一个元素中的零或多个。匹配应该涵盖整个输入字符串-而不是部分-。函数原型应该是：Bool-isMatch-Const-char-s，Const-char-p-一些示例：isMatch-“aa”，”a”-→false-isMatch-“aa”，”aa”-→true-isMatch-“aaa”，”aa”-→false-isMatch-“aa”，”a-“-→true-isMatch-“aa”，”-“-→trueISMatch-“ab”，”-“-→true-isMatch-“aAB”，”c-a-b”-→true"><span class="nav-number">4.6.</span> <span class="nav-text">3.6实现正则表达式匹配，支持”.”和”*“。”.”匹配任何单个字符。”*“匹配前一个元素中的零或多个。匹配应该涵盖整个输入字符串(而不是部分)。函数原型应该是：Bool isMatch(Const char*s，Const char*p)一些示例：isMatch(“aa”，”a”)→false isMatch(“aa”，”aa”)→true isMatch(“aaa”，”aa”)→false isMatch(“aa”，”a*“)→true isMatch(“aa”，”.*“)→trueISMatch(“ab”，”.*“)→true isMatch(“aAB”，”c*a*b”)→true</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7实现通配符模式匹配，并支持”？”和”-“。”-“匹配任何字符序列-包括空序列-。匹配应该覆盖整个输入字符串-而不是部分-。函数原型应该是：bool-isMatch-const-char-s，const-char-p-一些示例：isMatch-“aa”，”a”-→false-isMatch-“aa”，”aa”-→true-isMatch-“aaa”，”aa”-→false-isMatch-“aa”，”-“-→true-isMatch-“aa”，”a-“-→true-isMatch-“ab”，”？-“-→true-isMatch-“aAB”，”c-a-b”-→false"><span class="nav-number">4.7.</span> <span class="nav-text">3.7实现通配符模式匹配，并支持”？”和”*“。”*“匹配任何字符序列(包括空序列)。匹配应该覆盖整个输入字符串(而不是部分)。函数原型应该是：bool isMatch(const char*s，const char*p)一些示例：isMatch(“aa”，”a”)→false isMatch(“aa”，”aa”)→true isMatch(“aaa”，”aa”)→false isMatch(“aa”，”*“)→true isMatch(“aa”，”a*“)→true isMatch(“ab”，”？*“)→true isMatch(“aAB”，”c*a*b”)→false</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8编写一个函数来查找字符串数组中最长的公共前缀字符串。"><span class="nav-number">4.8.</span> <span class="nav-text">3.8编写一个函数来查找字符串数组中最长的公共前缀字符串。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9验证给定字符串是否为数字。一些例子：“0”-gt-true；“0-1”-gt-true；“abc”-gt-false；“1a”-gt-false；“2e10”-gt-true。-注意：它的目的是使问题陈述含糊不清。在实现一个需求之前，您应该先收集所有的需求。"><span class="nav-number">4.9.</span> <span class="nav-text">3.9验证给定字符串是否为数字。一些例子：“0”=&gt;true；“0.1”=&gt;true；“abc”=&gt;false；“1a”=&gt;false；“2e10”=&gt;true。 注意：它的目的是使问题陈述含糊不清。在实现一个需求之前，您应该先收集所有的需求。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10给定一个整数，将其转换为一个罗马数字。输入保证在1到3999之间。"><span class="nav-number">4.10.</span> <span class="nav-text">3.10给定一个整数，将其转换为一个罗马数字。输入保证在1到3999之间。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-11给定一个罗马数字，将其转换为整数。输入保证在1到3999之间。"><span class="nav-number">4.11.</span> <span class="nav-text">3.11给定一个罗马数字，将其转换为整数。输入保证在1到3999之间。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12计数和表示序列是整数的序列，开头如下：1，11，21，1211，111221，…。1被读出为“one-1”或11。11被读出为“two-1s”或21。21被读出为“one-2”，然后“one-1”或1211。给定一个整数n，生成第n个顺序。注意：整数序列将表示为字符串。"><span class="nav-number">4.12.</span> <span class="nav-text">3.12计数和表示序列是整数的序列，开头如下：1，11，21，1211，111221，…。1被读出为“one 1”或11。11被读出为“two 1s”或21。21被读出为“one 2”，然后“one 1”或1211。给定一个整数n，生成第n个顺序。注意：整数序列将表示为字符串。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-13给定一个字符串数组，返回所有字符串组。注意：所有输入都是小写的。"><span class="nav-number">4.13.</span> <span class="nav-text">3.13给定一个字符串数组，返回所有字符串组。注意：所有输入都是小写的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-14给定文件-Unix样式-的绝对路径，简化它。例如，path-“-home-”-gt-“-home”；path-“-a-b-c-”-gt-“-c”。情况：·您考虑过path-“-”的情况吗？在这种情况下，您应该返回“-”。·另一种情况是路径可能包含多个斜杠‘-’，例如“-home-foo-”。在这种情况下，您应该忽略多余的斜杠并返回“-home-foo”。"><span class="nav-number">4.14.</span> <span class="nav-text">3.14给定文件(Unix样式)的绝对路径，简化它。例如，path=“/home/”=&gt;“/home”；path=“/a/.b/./c/”=&gt;“/c”。情况：·您考虑过path=“/../”的情况吗？在这种情况下，您应该返回“/”。·另一种情况是路径可能包含多个斜杠‘/’，例如“/home/foo/”。在这种情况下，您应该忽略多余的斜杠并返回“/home/foo”。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-15如果字符串s由大小写字母和空格字符’-‘组成，则返回字符串中最后一个单词的长度。如果最后一个单词不存在，则返回0。注意：单词被定义为仅由非空格字符组成的字符序列。例如，给定s-“hello-world”，返回5。"><span class="nav-number">4.15.</span> <span class="nav-text">3.15如果字符串s由大小写字母和空格字符’ ‘组成，则返回字符串中最后一个单词的长度。如果最后一个单词不存在，则返回0。注意：单词被定义为仅由非空格字符组成的字符序列。例如，给定s=“hello world”，返回5。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1栈"><span class="nav-number">5.</span> <span class="nav-text">4.1栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1给定一个只包含字符’-‘-’-’-’-‘-’-’-’-‘和’-’的字符串，确定输入字符串是否有效。括号必须按照正确的顺序结束，”-”和”-”都是有效的，但是”-”和”-”不是。"><span class="nav-number">5.1.</span> <span class="nav-text">4.1.1给定一个只包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’的字符串，确定输入字符串是否有效。括号必须按照正确的顺序结束，”()”和”()[]”都是有效的，但是”(]”和”([)]”不是。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2给定一个只包含字符‘-’和‘-’的字符串，查找最长的有效-格式良好-括号的长度。对于“-”，最长的有效括号子字符串是“-”，它的长度-2。另一个例子是“-”，其中最长的有效括号子字符串是“-”，它的长度-4。"><span class="nav-number">5.2.</span> <span class="nav-text">4.1.2给定一个只包含字符‘(’和‘)’的字符串，查找最长的有效(格式良好)括号的长度。对于“(()”，最长的有效括号子字符串是“()”，它的长度=2。另一个例子是“)()())”，其中最长的有效括号子字符串是“()()”，它的长度=4。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3给定n个非负整数表示直方图的条高，其中每条的宽度为1，则在直方图中找出最大矩形的面积。"><span class="nav-number">5.3.</span> <span class="nav-text">4.1.3给定n个非负整数表示直方图的条高，其中每条的宽度为1，则在直方图中找出最大矩形的面积。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4用反波兰法计算算术表达式的值。有效运算符是-，-，，-。每个操作数可能是一个整数或另一个表达式。例如：-“2”-”1”-”-”-”3”-”“-gt-2-1-3-gt-9；-“4”-”13”-”5”-”-“-”-”-gt-4-13-5-gt-6"><span class="nav-number">5.4.</span> <span class="nav-text">4.1.4用反波兰法计算算术表达式的值。有效运算符是+，-，，/。每个操作数可能是一个整数或另一个表达式。例如：[“2”,”1”,”+”,”3”,”“)-&gt;((2+1)*3)-&gt;9；[“4”,”13”,”5”,”/“,”+”]-&gt;(4+(13/5))-&gt;6</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7查找"><span class="nav-number">6.</span> <span class="nav-text">7查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1给定一个排序的整数数组，找到给定目标值的起始和结束位置。算法的运行时复杂度必须是O-logn-的顺序。如果在数组中找不到目标，返回-1，-1-。例如，给定-5，7，7，8，8，10-和目标值8，返回-3，4-。–34"><span class="nav-number">6.1.</span> <span class="nav-text">7.1给定一个排序的整数数组，找到给定目标值的起始和结束位置。算法的运行时复杂度必须是O(logn)的顺序。如果在数组中找不到目标，返回[-1，-1]。例如，给定[5，7，7，8，8，10]和目标值8，返回[3，4]。–34</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2给定一个排序数组和一个目标值，如果找到目标，返回索引。如果没有，则返回索引，如果它是按顺序插入的话。您可以假设数组中没有重复项。-1-3-5-6-5-→-2；-1-3-5-6-2-→-1；-1-3-5-6-7-→-4；-1-3-5-6-0-→-0"><span class="nav-number">6.2.</span> <span class="nav-text">7.2给定一个排序数组和一个目标值，如果找到目标，返回索引。如果没有，则返回索引，如果它是按顺序插入的话。您可以假设数组中没有重复项。[1,3,5,6], 5 → 2；[1,3,5,6], 2 → 1；[1,3,5,6], 7 → 4；[1,3,5,6], 0 → 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3编写一个在m×n矩阵中搜索值的有效算法。该矩阵具有以下属性：-每行中的整数从左到右排序。·每一行的第一个整数大于上一行的最后一个整数。-1-3-5-7-10-11-16-20-23-30-34-50-，给定目标值-3，返回true。"><span class="nav-number">6.3.</span> <span class="nav-text">7.3编写一个在m×n矩阵中搜索值的有效算法。该矩阵具有以下属性：.每行中的整数从左到右排序。·每一行的第一个整数大于上一行的最后一个整数。[[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 50]]，给定目标值=3，返回true。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-暴力枚举法"><span class="nav-number">7.</span> <span class="nav-text">8.暴力枚举法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1给定一组不同的整数S，返回所有可能的子集。注：子集中的元素必须是非降序的。·解集不能包含重复的子集。例如，如果S-1，2，3-，解决方案是：-3-1-2-1-2-3-1-3-2-3-1-2-。"><span class="nav-number">7.1.</span> <span class="nav-text">8.1给定一组不同的整数S，返回所有可能的子集。注：子集中的元素必须是非降序的。·解集不能包含重复的子集。例如，如果S=[1，2，3]，解决方案是：[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2给定可能包含重复项的整数集合，返回所有可能的子集合。注意：子集中的元素必须是非降序的。解决方案集不能包含重复子集。例如，如果S-1，2，2-，解决方案是：-2-1-1-2-2-2-2-1-2-。"><span class="nav-number">7.2.</span> <span class="nav-text">8.2给定可能包含重复项的整数集合，返回所有可能的子集合。注意：子集中的元素必须是非降序的。解决方案集不能包含重复子集。例如，如果S=[1，2，2]，解决方案是：[[2],[1],[1,2,2],[2,2],[1,2],[]]。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-广度优先搜索"><span class="nav-number">8.</span> <span class="nav-text">9.广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1给定两个单词-开始和结束-和一个字典，找到从开始到结束的最短转换序列的长度，这样：·一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start-”hit”-end-”cog”-dict-“hot”-”dot”-”dog”-”lot”-”log”-，作为一个最短的转换是”hit”-gt-”hot”-gt-”dot”-gt-”dog”-gt-”cog”，返回它的长度5。注意：如果没有这样的转换序列，返回0。所有单词都有相同的长度。所有单词只包含小写字母字符。–127"><span class="nav-number">8.1.</span> <span class="nav-text">9.1给定两个单词(开始和结束)和一个字典，找到从开始到结束的最短转换序列的长度，这样：·一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start=”hit” end=”cog” dict=[“hot”,”dot”,”dog”,”lot”,”log”]，作为一个最短的转换是”hit”-&gt;”hot”-&gt;”dot”-&gt;”dog”-&gt;”cog”，返回它的长度5。注意：如果没有这样的转换序列，返回0。所有单词都有相同的长度。所有单词只包含小写字母字符。–127</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2给定两个单词-开始和结束-和一个字典，从开始到结束查找所有最短的转换序列，这样：一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start-“hit”-end-“cog”-dict-“hot”-”dot”-”dog”-”lot”-”log”-，返回-“hit”-”hot”-”dot”-”dog”-”cog”-“hit”-”hot”-”lot”-”log”-”cog”-。注：·所有单词的长度相同。·所有单词只包含小写字母字符"><span class="nav-number">8.2.</span> <span class="nav-text">9.2给定两个单词(开始和结束)和一个字典，从开始到结束查找所有最短的转换序列，这样：一次只能更改一个字母。每个中间单词必须存在于字典中，例如：start = “hit” end = “cog” dict = [“hot”,”dot”,”dog”,”lot”,”log”]，返回[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]。注：·所有单词的长度相同。·所有单词只包含小写字母字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3给定一个包含“x”和“o”的2D板，捕获所有被“x”包围的区域。一个区域是通过将“o”翻转到“x”来捕获的。例如，在运行您的功能之后，板子应该是："><span class="nav-number">8.3.</span> <span class="nav-text">9.3给定一个包含“x”和“o”的2D板，捕获所有被“x”包围的区域。一个区域是通过将“o”翻转到“x”来捕获的。例如，在运行您的功能之后，板子应该是：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10深度优先搜索"><span class="nav-number">9.</span> <span class="nav-text">10深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1给定字符串s，分区s使得分区的每个子字符串都是回文。返回S的所有可能的回文分区。例如，给定s-“AAB”，返回-“aa”-”b”-，-“a”-”b”-。–131"><span class="nav-number">9.1.</span> <span class="nav-text">10.1给定字符串s，分区s使得分区的每个子字符串都是回文。返回S的所有可能的回文分区。例如，给定s=“AAB”，返回[“aa”,”b”]，[“a”,”b”]。–131</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2机器人位于m×n网格的左上角-在下图中标记为“start”-。机器人只能在任何时间点向下或向右移动。机器人试图到达网格的右下角-在下图中标记为“Finish”-。有多少条可能的唯一路径？"><span class="nav-number">9.2.</span> <span class="nav-text">10.2机器人位于m×n网格的左上角(在下图中标记为“start”)。机器人只能在任何时间点向下或向右移动。机器人试图到达网格的右下角(在下图中标记为“Finish”)。有多少条可能的唯一路径？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3跟踪“唯一路径”：现在考虑是否在网格中添加了一些障碍。会有多少条唯一的路径？在网格中，一个障碍和空间分别标记为1和0。例如，在3×3网格的中间有一个障碍，如下图所示。唯一路径的总数为2。"><span class="nav-number">9.3.</span> <span class="nav-text">10.3跟踪“唯一路径”：现在考虑是否在网格中添加了一些障碍。会有多少条唯一的路径？在网格中，一个障碍和空间分别标记为1和0。例如，在3×3网格的中间有一个障碍，如下图所示。唯一路径的总数为2。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4n皇后之谜是在n×n棋盘上放置n个皇后的问题，这样就不会有两个皇后互相攻击。给定一个整数n，返回n皇后谜题的所有不同的解。每个解都包含n皇后位置的一个不同的板配置，其中‘Q’和‘-’都分别表示一个皇后和一个空间。例如，对于4皇后之谜，有两种不同的解决方案："><span class="nav-number">9.4.</span> <span class="nav-text">10.4n皇后之谜是在n×n棋盘上放置n个皇后的问题，这样就不会有两个皇后互相攻击。给定一个整数n，返回n皇后谜题的所有不同的解。每个解都包含n皇后位置的一个不同的板配置，其中‘Q’和‘.’都分别表示一个皇后和一个空间。例如，对于4皇后之谜，有两种不同的解决方案：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11分治法"><span class="nav-number">10.</span> <span class="nav-text">11分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1pow-x-n"><span class="nav-number">10.1.</span> <span class="nav-text">11.1pow(x,n)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12贪心法"><span class="nav-number">11.</span> <span class="nav-text">12贪心法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1给定一个非负整数数组，您最初定位在数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳转长度。确定您是否能够到达最后一个索引。例如：a-2，3，1，1，4-，返回true-a-3，2，1，0，4-，返回false。"><span class="nav-number">11.1.</span> <span class="nav-text">12.1给定一个非负整数数组，您最初定位在数组的第一个索引处。数组中的每个元素表示您在该位置的最大跳转长度。确定您是否能够到达最后一个索引。例如：a=[2，3，1，1，4]，返回true.a=[3，2，1，0，4]，返回false。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3假设您有一个数组，其中第一个元素是第一天给定股票的价格。如果只允许您完成最多一笔交易-即购买一只股票并卖出一股票-，那么设计一个算法来寻找最大利润。"><span class="nav-number">11.2.</span> <span class="nav-text">12.3假设您有一个数组，其中第一个元素是第一天给定股票的价格。如果只允许您完成最多一笔交易(即购买一只股票并卖出一股票)，那么设计一个算法来寻找最大利润。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-4假设你有一个数组，其中第一个元素是第一天的股票价格。设计一个算法来找到最大利润。你可以完成任意多个交易-即买一股，多次卖出一股-。但是，你不能同时进行多个交易-也就是说，你必须在再次买进之前卖掉股票-。"><span class="nav-number">11.3.</span> <span class="nav-text">12.4假设你有一个数组，其中第一个元素是第一天的股票价格。设计一个算法来找到最大利润。你可以完成任意多个交易(即买一股，多次卖出一股)。但是，你不能同时进行多个交易(也就是说，你必须在再次买进之前卖掉股票)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-5给定一个字符串，找出没有重复字符的最长子字符串的长度。例如，“abCabcbb”中没有重复字母的最长子字符串是“abc”，最长子字符串的长度为3，对于“bbbbb”，最长的子字符串为“b”，长度为1。"><span class="nav-number">11.4.</span> <span class="nav-text">12.5给定一个字符串，找出没有重复字符的最长子字符串的长度。例如，“abCabcbb”中没有重复字母的最长子字符串是“abc”，最长子字符串的长度为3，对于“bbbbb”，最长的子字符串为“b”，长度为1。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-6给定n个非负整数a1-a2-…-an，其中每个表示坐标-i-ai-上的一个点。n条垂直线的绘制使第一行的两个端点位于-i-ai-和-i-0-。找到两条线，与x轴一起形成一个容器，这样容器包含最多的水。注意：您不能倾斜容器。"><span class="nav-number">11.5.</span> <span class="nav-text">12.6给定n个非负整数a1,a2,…,an，其中每个表示坐标(i,ai)上的一个点。n条垂直线的绘制使第一行的两个端点位于(i,ai)和(i,0)。找到两条线，与x轴一起形成一个容器，这样容器包含最多的水。注意：您不能倾斜容器。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13动态规划"><span class="nav-number">12.</span> <span class="nav-text">13动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-1给定一个三角形，找出从上到下的最小路径和。每一步你都可以移动到下面行的相邻数。例如，给定以下三角形-2-，-3，4-，-6，5，7-，-4，1，8，3-，从上到下的最小路径和为11-即2-3-5-1-11-。注意：如果您只使用O-n-额外的空间就可以做到这一点，其中n是三角形中的行总数。"><span class="nav-number">12.1.</span> <span class="nav-text">13.1给定一个三角形，找出从上到下的最小路径和。每一步你都可以移动到下面行的相邻数。例如，给定以下三角形[2]，[3，4]，[6，5，7]，[4，1，8，3]，从上到下的最小路径和为11(即2+3+5+1=11)。注意：如果您只使用O(n)额外的空间就可以做到这一点，其中n是三角形中的行总数。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2在一个具有最大和的数组-至少包含一个数-中查找相邻子数组。例如，给定数组-−2，1，−3，4，−1，2，1，−5，4-，相邻子数组-4，−1，2，1-的和最大-6。"><span class="nav-number">12.2.</span> <span class="nav-text">13.2在一个具有最大和的数组(至少包含一个数)中查找相邻子数组。例如，给定数组[−2，1，−3，4，−1，2，1，−5，4]，相邻子数组[4，−1，2，1]的和最大=6。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3给定字符串s，分区s使得分区的每个子字符串都是回文。返回回文分区S所需的最小割集。例如，给定s-“AAB”，返回1，因为回文分区-“AA”，“b”-可以使用1-Cut生成。"><span class="nav-number">12.3.</span> <span class="nav-text">13.3给定字符串s，分区s使得分区的每个子字符串都是回文。返回回文分区S所需的最小割集。例如，给定s=“AAB”，返回1，因为回文分区[“AA”，“b”]可以使用1 Cut生成。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-4给定一个包含0和1的2D二进制矩阵，找到包含所有的最大矩形并返回其面积。"><span class="nav-number">12.4.</span> <span class="nav-text">13.4给定一个包含0和1的2D二进制矩阵，找到包含所有的最大矩形并返回其面积。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-5假设你有一个数组，其中第i个元素是第i天给定股票的价格。设计一个算法来找到最大利润。你最多可以完成两个交易。注意：你不能同时进行多个交易-也就是说，你必须在再次买进之前卖掉股票-。"><span class="nav-number">12.5.</span> <span class="nav-text">13.5假设你有一个数组，其中第i个元素是第i天给定股票的价格。设计一个算法来找到最大利润。你最多可以完成两个交易。注意：你不能同时进行多个交易(也就是说，你必须在再次买进之前卖掉股票)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-6给定s1-s2-s3，查找s3是否由s1和s2交织而成。例如，给定：s1-“aabc”，s2-“dbbca”，当s3-“aadbbcbcac”时，返回true。当s3-“aadbbbaccc”时，返回false。"><span class="nav-number">12.6.</span> <span class="nav-text">13.6给定s1,s2,s3，查找s3是否由s1和s2交织而成。例如，给定：s1=“aabc”，s2=“dbbca”，当s3=“aadbbcbcac”时，返回true。当s3=“aadbbbaccc”时，返回false。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-7给定一个字符串S1，我们可以通过递归地将它划分为两个非空子字符串来将它表示为二叉树。下面是S1-“great”的一种可能的表示形式：为了置乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。例如，如果我们选择节点“gr”并交换它的两个子节点，它会产生一个加扰字符串“rgeat”。我们说“rgeat”是一个“great”的置乱字符串，类似地，如果我们继续交换节点的子节点“Eat”和“at”，它会产生一个加扰字符串“rgtae”。我们说“rgtae”是一个“great”的置乱字符串，给定两个长度相同的字符串s1和s2，确定s2是否是s1的加扰字符串。"><span class="nav-number">12.7.</span> <span class="nav-text">13.7给定一个字符串S1，我们可以通过递归地将它划分为两个非空子字符串来将它表示为二叉树。下面是S1=“great”的一种可能的表示形式：为了置乱字符串，我们可以选择任何非叶节点并交换它的两个子节点。例如，如果我们选择节点“gr”并交换它的两个子节点，它会产生一个加扰字符串“rgeat”。我们说“rgeat”是一个“great”的置乱字符串，类似地，如果我们继续交换节点的子节点“Eat”和“at”，它会产生一个加扰字符串“rgtae”。我们说“rgtae”是一个“great”的置乱字符串，给定两个长度相同的字符串s1和s2，确定s2是否是s1的加扰字符串。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-8给定一个由非负数填充的m×n网格，从左上角到右下角寻找一条路径，使沿着其路径的所有数字之和最小化。注意：您只能在任何时间点向下或向右移动。"><span class="nav-number">12.8.</span> <span class="nav-text">13.8给定一个由非负数填充的m×n网格，从左上角到右下角寻找一条路径，使沿着其路径的所有数字之和最小化。注意：您只能在任何时间点向下或向右移动。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-9给定两个单词Word1和Word2，找到将Word1转换为Word2所需的最小步骤数。-每个操作都算作1步。-您可以对一个单词执行以下3个操作：插入一个字符，删除一个字符，替换一个字符"><span class="nav-number">12.9.</span> <span class="nav-text">13.9给定两个单词Word1和Word2，找到将Word1转换为Word2所需的最小步骤数。(每个操作都算作1步。)您可以对一个单词执行以下3个操作：插入一个字符，删除一个字符，替换一个字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-10一个包含来自AZ的字母的消息使用下面的映射被编码成数字：‘A’-gt-1，’B’-gt-2，…，’Z’-gt-26。给定包含数字的编码消息，确定解码方式的总数。例如，给定的编码消息“12”，可以解码为“ab”-1-2-或“l”-12-。解码“12”的方式数为2。"><span class="nav-number">12.10.</span> <span class="nav-text">13.10一个包含来自AZ的字母的消息使用下面的映射被编码成数字：‘A’-&gt; 1，’B’ -&gt; 2，…，’Z’ -&gt; 26。给定包含数字的编码消息，确定解码方式的总数。例如，给定的编码消息“12”，可以解码为“ab”(1 2)或“l”(12)。解码“12”的方式数为2。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-11给定字符串s和字符串t，计算s中t的不同子序列数。字符串的子序列是一个新字符串，它是通过删除一些字符-可以是零-而不干扰其余字符的相对位置而形成的新字符串。-也就是说，“ACE”是“ABCDE”的子序列，而“AEC”不是-。下面是一个例子：s-“rabbbit”，t-“rabbit”返回3。"><span class="nav-number">12.11.</span> <span class="nav-text">13.11给定字符串s和字符串t，计算s中t的不同子序列数。字符串的子序列是一个新字符串，它是通过删除一些字符(可以是零)而不干扰其余字符的相对位置而形成的新字符串。(也就是说，“ACE”是“ABCDE”的子序列，而“AEC”不是)。下面是一个例子：s=“rabbbit”，t=“rabbit”返回3。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-12给定字符串s和单词字典，确定s是否可以分割成一个或多个字典单词的空格分隔序列。例如，给定s-“leetcode”，dict-“leet”，“code”-。返回true，因为“leetcode”可以分割为“leet-code”。"><span class="nav-number">12.12.</span> <span class="nav-text">13.12给定字符串s和单词字典，确定s是否可以分割成一个或多个字典单词的空格分隔序列。例如，给定s=“leetcode”，dict=[“leet”，“code”]。返回true，因为“leetcode”可以分割为“leet code”。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-13给定字符串s和单词字典，在s中添加空格以构造一个句子，其中每个单词都是有效的字典词。返回所有这样的语句。例如，给定s-“catsanddog”，dict-“cat”-“cats”-“and”-“sand”-“dog”-。一个解决方案是-“cats-and-dog”-“cat-sand-dog”-。"><span class="nav-number">12.13.</span> <span class="nav-text">13.13给定字符串s和单词字典，在s中添加空格以构造一个句子，其中每个单词都是有效的字典词。返回所有这样的语句。例如，给定s = “catsanddog”，dict = [“cat”, “cats”, “and”, “sand”, “dog”]。一个解决方案是[“cats and dog”, “cat sand dog”]。</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dty075</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  



  
  







  
  <script type="text/javascript" src="/io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/io/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/io/lib/three/three-waves.min.js"></script>

  
  <script type="text/javascript" src="/io/lib/three/canvas_lines.min.js"></script>


  


  <script type="text/javascript" src="/io/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/io/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/io/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/io/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/io/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/io/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/io/js/src/bootstrap.js?v=5.1.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/io/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/io/js/src/hook-duoshuo.js"></script>
  














  





  

  

  

  

  

  

</body>
</html>
